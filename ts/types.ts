/* eslint-disable */

// This file was automatically generated by `typescript.ts`.
// Do not modify it by hand. Instead, modify the source `.schema.yaml` files
// in the `schema` directory and run `npm run build:ts` to regenerate it.

type Null = null
type Boolean = boolean
type Integer = number
type Number = number
type String = string
type Object = Record<string, unknown>
type Primitives =
  | undefined
  | null
  | boolean
  | number
  | string
  | Array<unknown>
  | Object

// Remove properties from an Object if their value is undefined
const compact = <O extends object>(o: O): O =>
  Object.entries(o).reduce(
    (compactedO: O, [k, v]) =>
      v === undefined ? compactedO : { ...compactedO, [k]: v },
    {} as O
  )

export interface Types {
  Array: Array<unknown>
  ArrayValidator: ArrayValidator
  Article: Article
  AudioObject: AudioObject
  BlockContent: BlockContent
  Boolean: Boolean
  BooleanValidator: BooleanValidator
  Brand: Brand
  CitationIntentEnumeration: CitationIntentEnumeration
  Cite: Cite
  CiteGroup: CiteGroup
  Claim: Claim
  Code: Code
  CodeBlock: CodeBlock
  CodeChunk: CodeChunk
  CodeError: CodeError
  CodeExecutable: CodeExecutable
  CodeExecutableTypes: CodeExecutableTypes
  CodeExpression: CodeExpression
  CodeFragment: CodeFragment
  CodeTypes: CodeTypes
  Collection: Collection
  Comment: Comment
  ConstantValidator: ConstantValidator
  ContactPoint: ContactPoint
  ContactPointTypes: ContactPointTypes
  CreativeWork: CreativeWork
  CreativeWorkTypes: CreativeWorkTypes
  Datatable: Datatable
  DatatableColumn: DatatableColumn
  Date: Date
  DefinedTerm: DefinedTerm
  Delete: Delete
  Emphasis: Emphasis
  Entity: Entity
  EntityTypes: EntityTypes
  EnumValidator: EnumValidator
  Enumeration: Enumeration
  EnumerationTypes: EnumerationTypes
  Figure: Figure
  Function: Function
  Grant: Grant
  GrantTypes: GrantTypes
  Heading: Heading
  ImageObject: ImageObject
  Include: Include
  InlineContent: InlineContent
  Integer: Integer
  IntegerValidator: IntegerValidator
  Link: Link
  List: List
  ListItem: ListItem
  Mark: Mark
  MarkTypes: MarkTypes
  Math: Math
  MathBlock: MathBlock
  MathFragment: MathFragment
  MathTypes: MathTypes
  MediaObject: MediaObject
  MediaObjectTypes: MediaObjectTypes
  MonetaryGrant: MonetaryGrant
  Node: Node
  NontextualAnnotation: NontextualAnnotation
  Note: Note
  Null: Null
  Number: Number
  NumberValidator: NumberValidator
  Object: Object
  Organization: Organization
  Paragraph: Paragraph
  Parameter: Parameter
  Periodical: Periodical
  Person: Person
  PostalAddress: PostalAddress
  Product: Product
  PropertyValue: PropertyValue
  PublicationIssue: PublicationIssue
  PublicationVolume: PublicationVolume
  Quote: Quote
  QuoteBlock: QuoteBlock
  Review: Review
  SoftwareApplication: SoftwareApplication
  SoftwareEnvironment: SoftwareEnvironment
  SoftwareSession: SoftwareSession
  SoftwareSourceCode: SoftwareSourceCode
  String: String
  StringValidator: StringValidator
  Strong: Strong
  Subscript: Subscript
  Superscript: Superscript
  Table: Table
  TableCell: TableCell
  TableRow: TableRow
  ThematicBreak: ThematicBreak
  Thing: Thing
  ThingTypes: ThingTypes
  TupleValidator: TupleValidator
  Validator: Validator
  ValidatorTypes: ValidatorTypes
  Variable: Variable
  VideoObject: VideoObject
  VolumeMount: VolumeMount
}

/**
 * The most simple compound (ie. non-atomic like `number`, `string` etc) type.
 */
export interface Entity {
  type:
    | 'Entity'
    | 'ArrayValidator'
    | 'Article'
    | 'AudioObject'
    | 'BooleanValidator'
    | 'Brand'
    | 'CitationIntentEnumeration'
    | 'Cite'
    | 'CiteGroup'
    | 'Claim'
    | 'Code'
    | 'CodeBlock'
    | 'CodeChunk'
    | 'CodeError'
    | 'CodeExecutable'
    | 'CodeExpression'
    | 'CodeFragment'
    | 'Collection'
    | 'Comment'
    | 'ConstantValidator'
    | 'ContactPoint'
    | 'CreativeWork'
    | 'Datatable'
    | 'DatatableColumn'
    | 'Date'
    | 'DefinedTerm'
    | 'Delete'
    | 'Emphasis'
    | 'EnumValidator'
    | 'Enumeration'
    | 'Figure'
    | 'Function'
    | 'Grant'
    | 'Heading'
    | 'ImageObject'
    | 'Include'
    | 'IntegerValidator'
    | 'Link'
    | 'List'
    | 'ListItem'
    | 'Mark'
    | 'Math'
    | 'MathBlock'
    | 'MathFragment'
    | 'MediaObject'
    | 'MonetaryGrant'
    | 'NontextualAnnotation'
    | 'Note'
    | 'NumberValidator'
    | 'Organization'
    | 'Paragraph'
    | 'Parameter'
    | 'Periodical'
    | 'Person'
    | 'PostalAddress'
    | 'Product'
    | 'PropertyValue'
    | 'PublicationIssue'
    | 'PublicationVolume'
    | 'Quote'
    | 'QuoteBlock'
    | 'Review'
    | 'SoftwareApplication'
    | 'SoftwareEnvironment'
    | 'SoftwareSession'
    | 'SoftwareSourceCode'
    | 'StringValidator'
    | 'Strong'
    | 'Subscript'
    | 'Superscript'
    | 'Table'
    | 'TableCell'
    | 'TableRow'
    | 'ThematicBreak'
    | 'Thing'
    | 'TupleValidator'
    | 'Validator'
    | 'Variable'
    | 'VideoObject'
    | 'VolumeMount'
  id?: String
  meta?: Object
}

/**
 * Create a `Entity` node
 * @param props Object containing Entity schema properties as key/value pairs
 * @returns {Entity} Entity schema node
 */
export const entity = (props: Omit<Entity, 'type'> = {}): Entity => ({
  ...compact(props),
  type: 'Entity',
})

/**
 * A reference to a CreativeWork that is cited in another CreativeWork.
 */
export interface Cite extends Entity {
  type: 'Cite'
  target: String
  citationIntent?: Array<CitationIntentEnumeration>
  citationMode?:
    | 'Parenthetical'
    | 'Narrative'
    | 'NarrativeAuthor'
    | 'NarrativeYear'
    | 'normal'
    | 'suppressAuthor'
  citationPrefix?: String
  citationSuffix?: String
  content?: Array<InlineContent>
  pageEnd?: Integer | String
  pageStart?: Integer | String
  pagination?: String
}

/**
 * Create a `Cite` node
 * @param props Object containing Cite schema properties as key/value pairs
 * @returns {Cite} Cite schema node
 */
export const cite = (props: Omit<Cite, 'type'>): Cite => ({
  ...compact(props),
  type: 'Cite',
})

/**
 * A group of Cite nodes.
 */
export interface CiteGroup extends Entity {
  type: 'CiteGroup'
  items: Array<Cite>
}

/**
 * Create a `CiteGroup` node
 * @param props Object containing CiteGroup schema properties as key/value pairs
 * @returns {CiteGroup} CiteGroup schema node
 */
export const citeGroup = (props: Omit<CiteGroup, 'type'>): CiteGroup => ({
  ...compact(props),
  type: 'CiteGroup',
})

/**
 * Base type for non-executable (e.g. `CodeBlock`) and executable (e.g. `CodeExpression`) code nodes.
 */
export interface Code extends Entity {
  type:
    | 'Code'
    | 'CodeBlock'
    | 'CodeChunk'
    | 'CodeExecutable'
    | 'CodeExpression'
    | 'CodeFragment'
  text: String
  mediaType?: String
  programmingLanguage?: String
}

/**
 * Create a `Code` node
 * @param props Object containing Code schema properties as key/value pairs
 * @returns {Code} Code schema node
 */
export const code = (props: Omit<Code, 'type'>): Code => ({
  ...compact(props),
  type: 'Code',
})

/**
 * A code block.
 */
export interface CodeBlock extends Code {
  type: 'CodeBlock'
}

/**
 * Create a `CodeBlock` node
 * @param props Object containing CodeBlock schema properties as key/value pairs
 * @returns {CodeBlock} CodeBlock schema node
 */
export const codeBlock = (props: Omit<CodeBlock, 'type'>): CodeBlock => ({
  ...compact(props),
  type: 'CodeBlock',
})

/**
 * Base type for executable code nodes (i.e. `CodeChunk` and `CodeExpression`).
 */
export interface CodeExecutable extends Code {
  type: 'CodeExecutable' | 'CodeChunk' | 'CodeExpression'
  programmingLanguage: String
  compileDigest?: String
  errors?: Array<CodeError>
  executeDigest?: String
  executeDuration?: Number
  executeEnded?: Date
  executeStatus?: 'Scheduled' | 'Running' | 'Succeeded' | 'Failed' | 'Cancelled'
}

/**
 * Create a `CodeExecutable` node
 * @param props Object containing CodeExecutable schema properties as key/value pairs
 * @returns {CodeExecutable} CodeExecutable schema node
 */
export const codeExecutable = (
  props: Omit<CodeExecutable, 'type'>
): CodeExecutable => ({
  ...compact(props),
  type: 'CodeExecutable',
})

/**
 * A executable chunk of code.
 */
export interface CodeChunk extends CodeExecutable {
  type: 'CodeChunk'
  programmingLanguage: String
  caption?: Array<BlockContent> | String
  label?: String
  outputs?: Array<Node>
}

/**
 * Create a `CodeChunk` node
 * @param props Object containing CodeChunk schema properties as key/value pairs
 * @returns {CodeChunk} CodeChunk schema node
 */
export const codeChunk = (props: Omit<CodeChunk, 'type'>): CodeChunk => ({
  ...compact(props),
  type: 'CodeChunk',
})

/**
 * An executable programming code expression.
 */
export interface CodeExpression extends CodeExecutable {
  type: 'CodeExpression'
  programmingLanguage: String
  output?: Node
}

/**
 * Create a `CodeExpression` node
 * @param props Object containing CodeExpression schema properties as key/value pairs
 * @returns {CodeExpression} CodeExpression schema node
 */
export const codeExpression = (
  props: Omit<CodeExpression, 'type'>
): CodeExpression => ({
  ...compact(props),
  type: 'CodeExpression',
})

/**
 * Inline code.
 */
export interface CodeFragment extends Code {
  type: 'CodeFragment'
}

/**
 * Create a `CodeFragment` node
 * @param props Object containing CodeFragment schema properties as key/value pairs
 * @returns {CodeFragment} CodeFragment schema node
 */
export const codeFragment = (
  props: Omit<CodeFragment, 'type'>
): CodeFragment => ({
  ...compact(props),
  type: 'CodeFragment',
})

/**
 * An error that occurred when parsing, compiling or executing a Code node.
 */
export interface CodeError extends Entity {
  type: 'CodeError'
  errorMessage: String
  errorType?: String
  stackTrace?: String
}

/**
 * Create a `CodeError` node
 * @param props Object containing CodeError schema properties as key/value pairs
 * @returns {CodeError} CodeError schema node
 */
export const codeError = (props: Omit<CodeError, 'type'>): CodeError => ({
  ...compact(props),
  type: 'CodeError',
})

/**
 * A date encoded as a ISO 8601 string.
 */
export interface Date extends Entity {
  type: 'Date'
  value: String
}

/**
 * Create a `Date` node
 * @param props Object containing Date schema properties as key/value pairs
 * @returns {Date} Date schema node
 */
export const date = (props: Omit<Date, 'type'>): Date => ({
  ...compact(props),
  type: 'Date',
})

/**
 * A base class for nodes that mark some other inline content
 * in some way (e.g. as being emphasised, or quoted).
 */
export interface Mark extends Entity {
  type:
    | 'Mark'
    | 'Delete'
    | 'Emphasis'
    | 'NontextualAnnotation'
    | 'Quote'
    | 'Strong'
    | 'Subscript'
    | 'Superscript'
  content: Array<InlineContent>
}

/**
 * Create a `Mark` node
 * @param props Object containing Mark schema properties as key/value pairs
 * @returns {Mark} Mark schema node
 */
export const mark = (props: Omit<Mark, 'type'>): Mark => ({
  ...compact(props),
  type: 'Mark',
})

/**
 * Content that is marked for deletion
 */
export interface Delete extends Mark {
  type: 'Delete'
}

/**
 * Create a `Delete` node
 * @param props Object containing Delete schema properties as key/value pairs
 * @returns {Delete} Delete schema node
 */
export const del = (props: Omit<Delete, 'type'>): Delete => ({
  ...compact(props),
  type: 'Delete',
})

/**
 * Emphasised content.
 */
export interface Emphasis extends Mark {
  type: 'Emphasis'
}

/**
 * Create a `Emphasis` node
 * @param props Object containing Emphasis schema properties as key/value pairs
 * @returns {Emphasis} Emphasis schema node
 */
export const emphasis = (props: Omit<Emphasis, 'type'>): Emphasis => ({
  ...compact(props),
  type: 'Emphasis',
})

/**
 * The most generic type of item.
 */
export interface Thing extends Entity {
  type:
    | 'Thing'
    | 'Article'
    | 'AudioObject'
    | 'Brand'
    | 'CitationIntentEnumeration'
    | 'Claim'
    | 'Collection'
    | 'Comment'
    | 'ContactPoint'
    | 'CreativeWork'
    | 'Datatable'
    | 'DatatableColumn'
    | 'DefinedTerm'
    | 'Enumeration'
    | 'Figure'
    | 'Grant'
    | 'ImageObject'
    | 'ListItem'
    | 'MediaObject'
    | 'MonetaryGrant'
    | 'Organization'
    | 'Periodical'
    | 'Person'
    | 'PostalAddress'
    | 'Product'
    | 'PropertyValue'
    | 'PublicationIssue'
    | 'PublicationVolume'
    | 'Review'
    | 'SoftwareApplication'
    | 'SoftwareEnvironment'
    | 'SoftwareSession'
    | 'SoftwareSourceCode'
    | 'Table'
    | 'VideoObject'
    | 'VolumeMount'
  alternateNames?: Array<String>
  description?: Array<BlockContent> | Array<InlineContent> | String
  identifiers?: Array<PropertyValue | String>
  images?: Array<ImageObject | String>
  name?: String
  url?: String
}

/**
 * Create a `Thing` node
 * @param props Object containing Thing schema properties as key/value pairs
 * @returns {Thing} Thing schema node
 */
export const thing = (props: Omit<Thing, 'type'> = {}): Thing => ({
  ...compact(props),
  type: 'Thing',
})

/**
 * A brand used by an organization or person for labeling a product,
 * product group, or similar.
 */
export interface Brand extends Thing {
  type: 'Brand'
  name: String
  logo?: ImageObject | String
  reviews?: Array<String>
}

/**
 * Create a `Brand` node
 * @param props Object containing Brand schema properties as key/value pairs
 * @returns {Brand} Brand schema node
 */
export const brand = (props: Omit<Brand, 'type'>): Brand => ({
  ...compact(props),
  type: 'Brand',
})

/**
 * A contact point, usually within an organization.
 */
export interface ContactPoint extends Thing {
  type: 'ContactPoint' | 'PostalAddress'
  availableLanguages?: Array<String>
  emails?: Array<String>
  telephoneNumbers?: Array<String>
}

/**
 * Create a `ContactPoint` node
 * @param props Object containing ContactPoint schema properties as key/value pairs
 * @returns {ContactPoint} ContactPoint schema node
 */
export const contactPoint = (
  props: Omit<ContactPoint, 'type'> = {}
): ContactPoint => ({
  ...compact(props),
  type: 'ContactPoint',
})

/**
 * A creative work, including books, movies, photographs, software programs, etc.
 */
export interface CreativeWork extends Thing {
  type:
    | 'CreativeWork'
    | 'Article'
    | 'AudioObject'
    | 'Claim'
    | 'Collection'
    | 'Comment'
    | 'Datatable'
    | 'Figure'
    | 'ImageObject'
    | 'MediaObject'
    | 'Periodical'
    | 'PublicationIssue'
    | 'PublicationVolume'
    | 'Review'
    | 'SoftwareApplication'
    | 'SoftwareSourceCode'
    | 'Table'
    | 'VideoObject'
  about?: Array<ThingTypes>
  authors?: Array<Person | Organization>
  comments?: Array<Comment>
  content?: Array<Node> | String
  dateAccepted?: Date
  dateCreated?: Date
  dateModified?: Date
  datePublished?: Date
  dateReceived?: Date
  editors?: Array<Person>
  fundedBy?: Array<Grant | MonetaryGrant>
  funders?: Array<Person | Organization>
  genre?: Array<String>
  isPartOf?: CreativeWorkTypes
  keywords?: Array<String>
  licenses?: Array<CreativeWorkTypes | String>
  maintainers?: Array<Person | Organization>
  parts?: Array<CreativeWorkTypes>
  publisher?: Person | Organization
  references?: Array<CreativeWorkTypes | String>
  text?: String
  title?: Array<InlineContent> | String
  version?: String | Number
}

/**
 * Create a `CreativeWork` node
 * @param props Object containing CreativeWork schema properties as key/value pairs
 * @returns {CreativeWork} CreativeWork schema node
 */
export const creativeWork = (
  props: Omit<CreativeWork, 'type'> = {}
): CreativeWork => ({
  ...compact(props),
  type: 'CreativeWork',
})

/**
 * An article, including news and scholarly articles.
 */
export interface Article extends CreativeWork {
  type: 'Article'
  content?: Array<BlockContent>
  pageEnd?: Integer | String
  pageStart?: Integer | String
  pagination?: String
}

/**
 * Create a `Article` node
 * @param props Object containing Article schema properties as key/value pairs
 * @returns {Article} Article schema node
 */
export const article = (props: Omit<Article, 'type'> = {}): Article => ({
  ...compact(props),
  type: 'Article',
})

/**
 * A claim represents specific reviewable facts or statements.
 */
export interface Claim extends CreativeWork {
  type: 'Claim'
  content: Array<BlockContent>
  claimType?:
    | 'Statement'
    | 'Theorem'
    | 'Lemma'
    | 'Proof'
    | 'Postulate'
    | 'Hypothesis'
    | 'Proposition'
    | 'Corollary'
  label?: String
}

/**
 * Create a `Claim` node
 * @param props Object containing Claim schema properties as key/value pairs
 * @returns {Claim} Claim schema node
 */
export const claim = (props: Omit<Claim, 'type'>): Claim => ({
  ...compact(props),
  type: 'Claim',
})

/**
 * A collection of CreativeWorks or other artifacts.
 */
export interface Collection extends CreativeWork {
  type: 'Collection'
  parts: Array<CreativeWorkTypes>
}

/**
 * Create a `Collection` node
 * @param props Object containing Collection schema properties as key/value pairs
 * @returns {Collection} Collection schema node
 */
export const collection = (props: Omit<Collection, 'type'>): Collection => ({
  ...compact(props),
  type: 'Collection',
})

/**
 * A comment on an item, e.g on a Article, or SoftwareSourceCode.
 */
export interface Comment extends CreativeWork {
  type: 'Comment'
  commentAspect?: String
  parentItem?: Comment
}

/**
 * Create a `Comment` node
 * @param props Object containing Comment schema properties as key/value pairs
 * @returns {Comment} Comment schema node
 */
export const comment = (props: Omit<Comment, 'type'> = {}): Comment => ({
  ...compact(props),
  type: 'Comment',
})

/**
 * A table of data.
 */
export interface Datatable extends CreativeWork {
  type: 'Datatable'
  columns: Array<DatatableColumn>
}

/**
 * Create a `Datatable` node
 * @param props Object containing Datatable schema properties as key/value pairs
 * @returns {Datatable} Datatable schema node
 */
export const datatable = (props: Omit<Datatable, 'type'>): Datatable => ({
  ...compact(props),
  type: 'Datatable',
})

/**
 * A media object, such as an image, video, or audio object embedded in a web page or a
 * downloadable dataset.
 */
export interface MediaObject extends CreativeWork {
  type: 'MediaObject' | 'AudioObject' | 'ImageObject' | 'VideoObject'
  contentUrl: String
  bitrate?: Number
  contentSize?: Number
  embedUrl?: String
  mediaType?: String
}

/**
 * Create a `MediaObject` node
 * @param props Object containing MediaObject schema properties as key/value pairs
 * @returns {MediaObject} MediaObject schema node
 */
export const mediaObject = (props: Omit<MediaObject, 'type'>): MediaObject => ({
  ...compact(props),
  type: 'MediaObject',
})

/**
 * An audio file
 */
export interface AudioObject extends MediaObject {
  type: 'AudioObject'
  caption?: String
  transcript?: String
}

/**
 * Create a `AudioObject` node
 * @param props Object containing AudioObject schema properties as key/value pairs
 * @returns {AudioObject} AudioObject schema node
 */
export const audioObject = (props: Omit<AudioObject, 'type'>): AudioObject => ({
  ...compact(props),
  type: 'AudioObject',
})

/**
 * A column of data within a Datatable.
 */
export interface DatatableColumn extends Thing {
  type: 'DatatableColumn'
  name: String
  values: Array<Node>
  validator?: ArrayValidator
}

/**
 * Create a `DatatableColumn` node
 * @param props Object containing DatatableColumn schema properties as key/value pairs
 * @returns {DatatableColumn} DatatableColumn schema node
 */
export const datatableColumn = (
  props: Omit<DatatableColumn, 'type'>
): DatatableColumn => ({
  ...compact(props),
  type: 'DatatableColumn',
})

/**
 * A word, name, acronym, phrase, etc. with a formal definition.
 */
export interface DefinedTerm extends Thing {
  type: 'DefinedTerm'
  name: String
  termCode?: String
}

/**
 * Create a `DefinedTerm` node
 * @param props Object containing DefinedTerm schema properties as key/value pairs
 * @returns {DefinedTerm} DefinedTerm schema node
 */
export const definedTerm = (props: Omit<DefinedTerm, 'type'>): DefinedTerm => ({
  ...compact(props),
  type: 'DefinedTerm',
})

/**
 * A base for all validator types.
 */
export interface Validator extends Entity {
  type:
    | 'Validator'
    | 'ArrayValidator'
    | 'BooleanValidator'
    | 'ConstantValidator'
    | 'EnumValidator'
    | 'IntegerValidator'
    | 'NumberValidator'
    | 'StringValidator'
    | 'TupleValidator'
}

/**
 * Create a `Validator` node
 * @param props Object containing Validator schema properties as key/value pairs
 * @returns {Validator} Validator schema node
 */
export const validator = (props: Omit<Validator, 'type'> = {}): Validator => ({
  ...compact(props),
  type: 'Validator',
})

/**
 * A validator specifying constraints on an array node.
 */
export interface ArrayValidator extends Validator {
  type: 'ArrayValidator'
  contains?: ValidatorTypes
  itemsValidator?: ValidatorTypes
  maxItems?: Integer
  minItems?: Integer
  uniqueItems?: Boolean
}

/**
 * Create a `ArrayValidator` node
 * @param props Object containing ArrayValidator schema properties as key/value pairs
 * @returns {ArrayValidator} ArrayValidator schema node
 */
export const arrayValidator = (
  props: Omit<ArrayValidator, 'type'> = {}
): ArrayValidator => ({
  ...compact(props),
  type: 'ArrayValidator',
})

/**
 * A schema specifying that a node must be a boolean value.
 */
export interface BooleanValidator extends Validator {
  type: 'BooleanValidator'
}

/**
 * Create a `BooleanValidator` node
 * @param props Object containing BooleanValidator schema properties as key/value pairs
 * @returns {BooleanValidator} BooleanValidator schema node
 */
export const booleanValidator = (
  props: Omit<BooleanValidator, 'type'> = {}
): BooleanValidator => ({
  ...compact(props),
  type: 'BooleanValidator',
})

/**
 * A validator specifying a constant value that a node must have.
 */
export interface ConstantValidator extends Validator {
  type: 'ConstantValidator'
  value?: Node
}

/**
 * Create a `ConstantValidator` node
 * @param props Object containing ConstantValidator schema properties as key/value pairs
 * @returns {ConstantValidator} ConstantValidator schema node
 */
export const constantValidator = (
  props: Omit<ConstantValidator, 'type'> = {}
): ConstantValidator => ({
  ...compact(props),
  type: 'ConstantValidator',
})

/**
 * A schema specifying that a node must be one of several values.
 */
export interface EnumValidator extends Validator {
  type: 'EnumValidator'
  values?: Array<Node>
}

/**
 * Create a `EnumValidator` node
 * @param props Object containing EnumValidator schema properties as key/value pairs
 * @returns {EnumValidator} EnumValidator schema node
 */
export const enumValidator = (
  props: Omit<EnumValidator, 'type'> = {}
): EnumValidator => ({
  ...compact(props),
  type: 'EnumValidator',
})

/**
 * Lists or enumerations, for example, a list of cuisines or music genres, etc.
 */
export interface Enumeration extends Thing {
  type: 'Enumeration' | 'CitationIntentEnumeration'
}

/**
 * Create a `Enumeration` node
 * @param props Object containing Enumeration schema properties as key/value pairs
 * @returns {Enumeration} Enumeration schema node
 */
export const enumeration = (
  props: Omit<Enumeration, 'type'> = {}
): Enumeration => ({
  ...compact(props),
  type: 'Enumeration',
})

/**
 * Encapsulates one or more images, videos, tables, etc, and provides captions and labels for them.
 */
export interface Figure extends CreativeWork {
  type: 'Figure'
  caption?: Array<BlockContent> | String
  label?: String
}

/**
 * Create a `Figure` node
 * @param props Object containing Figure schema properties as key/value pairs
 * @returns {Figure} Figure schema node
 */
export const figure = (props: Omit<Figure, 'type'> = {}): Figure => ({
  ...compact(props),
  type: 'Figure',
})

/**
 * A function with a name, which might take Parameters and return a value of a certain type.
 */
export interface Function extends Entity {
  type: 'Function'
  name?: String
  parameters?: Array<Parameter>
  returns?: ValidatorTypes
}

/**
 * Create a `Function` node
 * @param props Object containing Function schema properties as key/value pairs
 * @returns {Function} Function schema node
 */
export const function_ = (props: Omit<Function, 'type'> = {}): Function => ({
  ...compact(props),
  type: 'Function',
})

/**
 * A grant, typically financial or otherwise quantifiable, of resources.
 */
export interface Grant extends Thing {
  type: 'Grant' | 'MonetaryGrant'
  fundedItems?: Array<Thing>
  sponsors?: Array<Person | Organization>
}

/**
 * Create a `Grant` node
 * @param props Object containing Grant schema properties as key/value pairs
 * @returns {Grant} Grant schema node
 */
export const grant = (props: Omit<Grant, 'type'> = {}): Grant => ({
  ...compact(props),
  type: 'Grant',
})

/**
 * A heading.
 */
export interface Heading extends Entity {
  type: 'Heading'
  content: Array<InlineContent>
  depth?: Integer
}

/**
 * Create a `Heading` node
 * @param props Object containing Heading schema properties as key/value pairs
 * @returns {Heading} Heading schema node
 */
export const heading = (props: Omit<Heading, 'type'>): Heading => ({
  ...compact(props),
  type: 'Heading',
})

/**
 * An image file.
 */
export interface ImageObject extends MediaObject {
  type: 'ImageObject'
  caption?: String
  thumbnail?: ImageObject
}

/**
 * Create a `ImageObject` node
 * @param props Object containing ImageObject schema properties as key/value pairs
 * @returns {ImageObject} ImageObject schema node
 */
export const imageObject = (props: Omit<ImageObject, 'type'>): ImageObject => ({
  ...compact(props),
  type: 'ImageObject',
})

/**
 * Include content from an external source (e.g. file, URL).
 */
export interface Include extends Entity {
  type: 'Include'
  source: String
  buildDigest?: String
  content?: Array<BlockContent>
  mediaType?: String
}

/**
 * Create a `Include` node
 * @param props Object containing Include schema properties as key/value pairs
 * @returns {Include} Include schema node
 */
export const include = (props: Omit<Include, 'type'>): Include => ({
  ...compact(props),
  type: 'Include',
})

/**
 * A validator specifying the constraints on an integer node.
 */
export interface IntegerValidator extends Validator {
  type: 'IntegerValidator'
}

/**
 * Create a `IntegerValidator` node
 * @param props Object containing IntegerValidator schema properties as key/value pairs
 * @returns {IntegerValidator} IntegerValidator schema node
 */
export const integerValidator = (
  props: Omit<IntegerValidator, 'type'> = {}
): IntegerValidator => ({
  ...compact(props),
  type: 'IntegerValidator',
})

/**
 * A hyperlink to other pages, sections within the same document, resources, or any URL.
 */
export interface Link extends Entity {
  type: 'Link'
  content: Array<InlineContent>
  target: String
  exportFrom?: String
  importTo?: String
  relation?: String
  title?: String
}

/**
 * Create a `Link` node
 * @param props Object containing Link schema properties as key/value pairs
 * @returns {Link} Link schema node
 */
export const link = (props: Omit<Link, 'type'>): Link => ({
  ...compact(props),
  type: 'Link',
})

/**
 * A list of items.
 */
export interface List extends Entity {
  type: 'List'
  items: Array<ListItem>
  order?: 'Ascending' | 'Descending' | 'Unordered'
}

/**
 * Create a `List` node
 * @param props Object containing List schema properties as key/value pairs
 * @returns {List} List schema node
 */
export const list = (props: Omit<List, 'type'>): List => ({
  ...compact(props),
  type: 'List',
})

/**
 * A single item in a list.
 */
export interface ListItem extends Thing {
  type: 'ListItem'
  content?: Array<BlockContent> | Array<InlineContent>
  isChecked?: Boolean
  item?: Node
  position?: Integer
}

/**
 * Create a `ListItem` node
 * @param props Object containing ListItem schema properties as key/value pairs
 * @returns {ListItem} ListItem schema node
 */
export const listItem = (props: Omit<ListItem, 'type'> = {}): ListItem => ({
  ...compact(props),
  type: 'ListItem',
})

/**
 * A mathematical variable or equation.
 */
export interface Math extends Entity {
  type: 'Math' | 'MathBlock' | 'MathFragment'
  text: String
  errors?: Array<String>
  mathLanguage?: String
}

/**
 * Create a `Math` node
 * @param props Object containing Math schema properties as key/value pairs
 * @returns {Math} Math schema node
 */
export const math = (props: Omit<Math, 'type'>): Math => ({
  ...compact(props),
  type: 'Math',
})

/**
 * A block of math, e.g an equation, to be treated as block content.
 */
export interface MathBlock extends Math {
  type: 'MathBlock'
  label?: String
}

/**
 * Create a `MathBlock` node
 * @param props Object containing MathBlock schema properties as key/value pairs
 * @returns {MathBlock} MathBlock schema node
 */
export const mathBlock = (props: Omit<MathBlock, 'type'>): MathBlock => ({
  ...compact(props),
  type: 'MathBlock',
})

/**
 * A fragment of math, e.g a variable name, to be treated as inline content.
 */
export interface MathFragment extends Math {
  type: 'MathFragment'
}

/**
 * Create a `MathFragment` node
 * @param props Object containing MathFragment schema properties as key/value pairs
 * @returns {MathFragment} MathFragment schema node
 */
export const mathFragment = (
  props: Omit<MathFragment, 'type'>
): MathFragment => ({
  ...compact(props),
  type: 'MathFragment',
})

/**
 * A monetary grant.
 */
export interface MonetaryGrant extends Grant {
  type: 'MonetaryGrant'
  amounts?: Number
  funders?: Array<Person | Organization>
}

/**
 * Create a `MonetaryGrant` node
 * @param props Object containing MonetaryGrant schema properties as key/value pairs
 * @returns {MonetaryGrant} MonetaryGrant schema node
 */
export const monetaryGrant = (
  props: Omit<MonetaryGrant, 'type'> = {}
): MonetaryGrant => ({
  ...compact(props),
  type: 'MonetaryGrant',
})

/**
 * Inline text that has a non-textual annotation.
 */
export interface NontextualAnnotation extends Mark {
  type: 'NontextualAnnotation'
}

/**
 * Create a `NontextualAnnotation` node
 * @param props Object containing NontextualAnnotation schema properties as key/value pairs
 * @returns {NontextualAnnotation} NontextualAnnotation schema node
 */
export const nontextualAnnotation = (
  props: Omit<NontextualAnnotation, 'type'>
): NontextualAnnotation => ({
  ...compact(props),
  type: 'NontextualAnnotation',
})

/**
 * Additional content which is not part of the main content of a document.
 */
export interface Note extends Entity {
  type: 'Note'
  content: Array<BlockContent>
  noteType?: 'Footnote' | 'Endnote' | 'Sidenote'
}

/**
 * Create a `Note` node
 * @param props Object containing Note schema properties as key/value pairs
 * @returns {Note} Note schema node
 */
export const note = (props: Omit<Note, 'type'>): Note => ({
  ...compact(props),
  type: 'Note',
})

/**
 * A validator specifying the constraints on a numeric node.
 */
export interface NumberValidator extends Validator {
  type: 'NumberValidator'
  exclusiveMaximum?: Number
  exclusiveMinimum?: Number
  maximum?: Number
  minimum?: Number
  multipleOf?: Number
}

/**
 * Create a `NumberValidator` node
 * @param props Object containing NumberValidator schema properties as key/value pairs
 * @returns {NumberValidator} NumberValidator schema node
 */
export const numberValidator = (
  props: Omit<NumberValidator, 'type'> = {}
): NumberValidator => ({
  ...compact(props),
  type: 'NumberValidator',
})

/**
 * An organization such as a school, NGO, corporation, club, etc.
 */
export interface Organization extends Thing {
  type: 'Organization'
  address?: PostalAddress | String
  brands?: Array<Brand>
  contactPoints?: Array<ContactPoint>
  departments?: Array<Organization>
  funders?: Array<Organization | Person>
  legalName?: String
  logo?: ImageObject | String
  members?: Array<Organization | Person>
  parentOrganization?: Organization
}

/**
 * Create a `Organization` node
 * @param props Object containing Organization schema properties as key/value pairs
 * @returns {Organization} Organization schema node
 */
export const organization = (
  props: Omit<Organization, 'type'> = {}
): Organization => ({
  ...compact(props),
  type: 'Organization',
})

/**
 * Paragraph
 */
export interface Paragraph extends Entity {
  type: 'Paragraph'
  content: Array<InlineContent>
}

/**
 * Create a `Paragraph` node
 * @param props Object containing Paragraph schema properties as key/value pairs
 * @returns {Paragraph} Paragraph schema node
 */
export const paragraph = (props: Omit<Paragraph, 'type'>): Paragraph => ({
  ...compact(props),
  type: 'Paragraph',
})

/**
 * A parameter of a document or function.
 */
export interface Parameter extends Entity {
  type: 'Parameter'
  name: String
  default?: Node
  executeDigest?: String
  isExtensible?: Boolean
  isRequired?: Boolean
  isVariadic?: Boolean
  validator?: ValidatorTypes
  value?: Node
}

/**
 * Create a `Parameter` node
 * @param props Object containing Parameter schema properties as key/value pairs
 * @returns {Parameter} Parameter schema node
 */
export const parameter = (props: Omit<Parameter, 'type'>): Parameter => ({
  ...compact(props),
  type: 'Parameter',
})

/**
 * A periodical publication.
 */
export interface Periodical extends CreativeWork {
  type: 'Periodical'
  dateEnd?: Date
  dateStart?: Date
  issns?: Array<String>
}

/**
 * Create a `Periodical` node
 * @param props Object containing Periodical schema properties as key/value pairs
 * @returns {Periodical} Periodical schema node
 */
export const periodical = (
  props: Omit<Periodical, 'type'> = {}
): Periodical => ({
  ...compact(props),
  type: 'Periodical',
})

/**
 * A person (alive, dead, undead, or fictional).
 */
export interface Person extends Thing {
  type: 'Person'
  address?: PostalAddress | String
  affiliations?: Array<Organization>
  emails?: Array<String>
  familyNames?: Array<String>
  funders?: Array<Organization | Person>
  givenNames?: Array<String>
  honorificPrefix?: String
  honorificSuffix?: String
  jobTitle?: String
  memberOf?: Array<Organization>
  telephoneNumbers?: Array<String>
}

/**
 * Create a `Person` node
 * @param props Object containing Person schema properties as key/value pairs
 * @returns {Person} Person schema node
 */
export const person = (props: Omit<Person, 'type'> = {}): Person => ({
  ...compact(props),
  type: 'Person',
})

/**
 * A physical mailing address.
 */
export interface PostalAddress extends ContactPoint {
  type: 'PostalAddress'
  addressCountry?: String
  addressLocality?: String
  addressRegion?: String
  postOfficeBoxNumber?: String
  postalCode?: String
  streetAddress?: String
}

/**
 * Create a `PostalAddress` node
 * @param props Object containing PostalAddress schema properties as key/value pairs
 * @returns {PostalAddress} PostalAddress schema node
 */
export const postalAddress = (
  props: Omit<PostalAddress, 'type'> = {}
): PostalAddress => ({
  ...compact(props),
  type: 'PostalAddress',
})

/**
 * Any offered product or service. For example, a pair of shoes;
 * a haircut; or an episode of a TV show streamed online.
 */
export interface Product extends Thing {
  type: 'Product'
  brands?: Array<Brand>
  logo?: ImageObject | String
  productID?: String
}

/**
 * Create a `Product` node
 * @param props Object containing Product schema properties as key/value pairs
 * @returns {Product} Product schema node
 */
export const product = (props: Omit<Product, 'type'> = {}): Product => ({
  ...compact(props),
  type: 'Product',
})

/**
 * A property-value pair.
 */
export interface PropertyValue extends Thing {
  type: 'PropertyValue'
  value: Boolean | Integer | Number | String
  propertyID?: String
}

/**
 * Create a `PropertyValue` node
 * @param props Object containing PropertyValue schema properties as key/value pairs
 * @returns {PropertyValue} PropertyValue schema node
 */
export const propertyValue = (
  props: Omit<PropertyValue, 'type'>
): PropertyValue => ({
  ...compact(props),
  type: 'PropertyValue',
})

/**
 * A part of a successively published publication such as a periodical or publication
 * volume, often numbered.
 */
export interface PublicationIssue extends CreativeWork {
  type: 'PublicationIssue'
  issueNumber?: Integer | String
  pageEnd?: Integer | String
  pageStart?: Integer | String
  pagination?: String
}

/**
 * Create a `PublicationIssue` node
 * @param props Object containing PublicationIssue schema properties as key/value pairs
 * @returns {PublicationIssue} PublicationIssue schema node
 */
export const publicationIssue = (
  props: Omit<PublicationIssue, 'type'> = {}
): PublicationIssue => ({
  ...compact(props),
  type: 'PublicationIssue',
})

/**
 * A part of a successively published publication such as a periodical or multi-volume work.
 */
export interface PublicationVolume extends CreativeWork {
  type: 'PublicationVolume'
  pageEnd?: Integer | String
  pageStart?: Integer | String
  pagination?: String
  volumeNumber?: Integer | String
}

/**
 * Create a `PublicationVolume` node
 * @param props Object containing PublicationVolume schema properties as key/value pairs
 * @returns {PublicationVolume} PublicationVolume schema node
 */
export const publicationVolume = (
  props: Omit<PublicationVolume, 'type'> = {}
): PublicationVolume => ({
  ...compact(props),
  type: 'PublicationVolume',
})

/**
 * Inline, quoted content.
 */
export interface Quote extends Mark {
  type: 'Quote'
  cite?: Cite | String
}

/**
 * Create a `Quote` node
 * @param props Object containing Quote schema properties as key/value pairs
 * @returns {Quote} Quote schema node
 */
export const quote = (props: Omit<Quote, 'type'>): Quote => ({
  ...compact(props),
  type: 'Quote',
})

/**
 * A section quoted from somewhere else.
 */
export interface QuoteBlock extends Entity {
  type: 'QuoteBlock'
  content: Array<BlockContent>
  cite?: Cite | String
}

/**
 * Create a `QuoteBlock` node
 * @param props Object containing QuoteBlock schema properties as key/value pairs
 * @returns {QuoteBlock} QuoteBlock schema node
 */
export const quoteBlock = (props: Omit<QuoteBlock, 'type'>): QuoteBlock => ({
  ...compact(props),
  type: 'QuoteBlock',
})

/**
 * A review of an item, e.g of an Article, or SoftwareSourceCode.
 */
export interface Review extends CreativeWork {
  type: 'Review'
  itemReviewed?: Thing
  reviewAspect?: String
}

/**
 * Create a `Review` node
 * @param props Object containing Review schema properties as key/value pairs
 * @returns {Review} Review schema node
 */
export const review = (props: Omit<Review, 'type'> = {}): Review => ({
  ...compact(props),
  type: 'Review',
})

/**
 * A software application.
 */
export interface SoftwareApplication extends CreativeWork {
  type: 'SoftwareApplication'
  softwareRequirements?: Array<SoftwareApplication>
  softwareVersion?: String
}

/**
 * Create a `SoftwareApplication` node
 * @param props Object containing SoftwareApplication schema properties as key/value pairs
 * @returns {SoftwareApplication} SoftwareApplication schema node
 */
export const softwareApplication = (
  props: Omit<SoftwareApplication, 'type'> = {}
): SoftwareApplication => ({
  ...compact(props),
  type: 'SoftwareApplication',
})

/**
 * A computational environment.
 */
export interface SoftwareEnvironment extends Thing {
  type: 'SoftwareEnvironment'
  name: String
  adds?: Array<SoftwareSourceCode>
  extends?: Array<SoftwareEnvironment>
  removes?: Array<SoftwareSourceCode>
}

/**
 * Create a `SoftwareEnvironment` node
 * @param props Object containing SoftwareEnvironment schema properties as key/value pairs
 * @returns {SoftwareEnvironment} SoftwareEnvironment schema node
 */
export const softwareEnvironment = (
  props: Omit<SoftwareEnvironment, 'type'>
): SoftwareEnvironment => ({
  ...compact(props),
  type: 'SoftwareEnvironment',
})

/**
 * Definition of a compute session, including its software and compute resource
 * requirements and status.
 */
export interface SoftwareSession extends Thing {
  type: 'SoftwareSession'
  clientsLimit?: Number
  clientsRequest?: Number
  cpuLimit?: Number
  cpuRequest?: Number
  dateEnd?: Date
  dateStart?: Date
  durationLimit?: Number
  durationRequest?: Number
  environment?: SoftwareEnvironment
  memoryLimit?: Number
  memoryRequest?: Number
  networkTransferLimit?: Number
  networkTransferRequest?: Number
  status?:
    | 'Unknown'
    | 'Starting'
    | 'Started'
    | 'Stopping'
    | 'Stopped'
    | 'Failed'
  timeoutLimit?: Number
  timeoutRequest?: Number
  volumeMounts?: Array<VolumeMount>
}

/**
 * Create a `SoftwareSession` node
 * @param props Object containing SoftwareSession schema properties as key/value pairs
 * @returns {SoftwareSession} SoftwareSession schema node
 */
export const softwareSession = (
  props: Omit<SoftwareSession, 'type'> = {}
): SoftwareSession => ({
  ...compact(props),
  type: 'SoftwareSession',
})

/**
 * Computer programming source code. Example: Full (compile ready) solutions, code snippet samples, scripts, templates.
 */
export interface SoftwareSourceCode extends CreativeWork {
  type: 'SoftwareSourceCode'
  codeRepository?: String
  codeSampleType?: String
  programmingLanguage?: String
  runtimePlatform?: Array<String>
  softwareRequirements?: Array<
    SoftwareSourceCode | SoftwareApplication | String
  >
  targetProducts?: Array<SoftwareApplication>
}

/**
 * Create a `SoftwareSourceCode` node
 * @param props Object containing SoftwareSourceCode schema properties as key/value pairs
 * @returns {SoftwareSourceCode} SoftwareSourceCode schema node
 */
export const softwareSourceCode = (
  props: Omit<SoftwareSourceCode, 'type'> = {}
): SoftwareSourceCode => ({
  ...compact(props),
  type: 'SoftwareSourceCode',
})

/**
 * A schema specifying constraints on a string node.
 */
export interface StringValidator extends Validator {
  type: 'StringValidator'
  maxLength?: Integer
  minLength?: Integer
  pattern?: String
}

/**
 * Create a `StringValidator` node
 * @param props Object containing StringValidator schema properties as key/value pairs
 * @returns {StringValidator} StringValidator schema node
 */
export const stringValidator = (
  props: Omit<StringValidator, 'type'> = {}
): StringValidator => ({
  ...compact(props),
  type: 'StringValidator',
})

/**
 * Strongly emphasised content.
 */
export interface Strong extends Mark {
  type: 'Strong'
}

/**
 * Create a `Strong` node
 * @param props Object containing Strong schema properties as key/value pairs
 * @returns {Strong} Strong schema node
 */
export const strong = (props: Omit<Strong, 'type'>): Strong => ({
  ...compact(props),
  type: 'Strong',
})

/**
 * Subscripted content.
 */
export interface Subscript extends Mark {
  type: 'Subscript'
}

/**
 * Create a `Subscript` node
 * @param props Object containing Subscript schema properties as key/value pairs
 * @returns {Subscript} Subscript schema node
 */
export const subscript = (props: Omit<Subscript, 'type'>): Subscript => ({
  ...compact(props),
  type: 'Subscript',
})

/**
 * Superscripted content.
 */
export interface Superscript extends Mark {
  type: 'Superscript'
}

/**
 * Create a `Superscript` node
 * @param props Object containing Superscript schema properties as key/value pairs
 * @returns {Superscript} Superscript schema node
 */
export const superscript = (props: Omit<Superscript, 'type'>): Superscript => ({
  ...compact(props),
  type: 'Superscript',
})

/**
 * A table.
 */
export interface Table extends CreativeWork {
  type: 'Table'
  rows: Array<TableRow>
  caption?: Array<BlockContent> | String
  label?: String
}

/**
 * Create a `Table` node
 * @param props Object containing Table schema properties as key/value pairs
 * @returns {Table} Table schema node
 */
export const table = (props: Omit<Table, 'type'>): Table => ({
  ...compact(props),
  type: 'Table',
})

/**
 * A cell within a `Table`.
 */
export interface TableCell extends Entity {
  type: 'TableCell'
  cellType?: 'Data' | 'Header'
  colspan?: Integer
  content?: Array<BlockContent> | Array<InlineContent>
  name?: String
  rowspan?: Integer
}

/**
 * Create a `TableCell` node
 * @param props Object containing TableCell schema properties as key/value pairs
 * @returns {TableCell} TableCell schema node
 */
export const tableCell = (props: Omit<TableCell, 'type'> = {}): TableCell => ({
  ...compact(props),
  type: 'TableCell',
})

/**
 * A row within a Table.
 */
export interface TableRow extends Entity {
  type: 'TableRow'
  cells: Array<TableCell>
  rowType?: 'Header' | 'Footer'
}

/**
 * Create a `TableRow` node
 * @param props Object containing TableRow schema properties as key/value pairs
 * @returns {TableRow} TableRow schema node
 */
export const tableRow = (props: Omit<TableRow, 'type'>): TableRow => ({
  ...compact(props),
  type: 'TableRow',
})

/**
 * A thematic break, such as a scene change in a story, a transition to another topic, or a new document.
 */
export interface ThematicBreak extends Entity {
  type: 'ThematicBreak'
}

/**
 * Create a `ThematicBreak` node
 * @param props Object containing ThematicBreak schema properties as key/value pairs
 * @returns {ThematicBreak} ThematicBreak schema node
 */
export const thematicBreak = (
  props: Omit<ThematicBreak, 'type'> = {}
): ThematicBreak => ({
  ...compact(props),
  type: 'ThematicBreak',
})

/**
 * A validator specifying constraints on an array of heterogeneous items.
 */
export interface TupleValidator extends Validator {
  type: 'TupleValidator'
  items?: Array<ValidatorTypes>
}

/**
 * Create a `TupleValidator` node
 * @param props Object containing TupleValidator schema properties as key/value pairs
 * @returns {TupleValidator} TupleValidator schema node
 */
export const tupleValidator = (
  props: Omit<TupleValidator, 'type'> = {}
): TupleValidator => ({
  ...compact(props),
  type: 'TupleValidator',
})

/**
 * A variable representing a name / value pair.
 */
export interface Variable extends Entity {
  type: 'Variable'
  name: String
  isReadonly?: Boolean
  validator?: ValidatorTypes
  value?: Node
}

/**
 * Create a `Variable` node
 * @param props Object containing Variable schema properties as key/value pairs
 * @returns {Variable} Variable schema node
 */
export const variable = (props: Omit<Variable, 'type'>): Variable => ({
  ...compact(props),
  type: 'Variable',
})

/**
 * A video file.
 */
export interface VideoObject extends MediaObject {
  type: 'VideoObject'
  caption?: String
  thumbnail?: ImageObject
  transcript?: String
}

/**
 * Create a `VideoObject` node
 * @param props Object containing VideoObject schema properties as key/value pairs
 * @returns {VideoObject} VideoObject schema node
 */
export const videoObject = (props: Omit<VideoObject, 'type'>): VideoObject => ({
  ...compact(props),
  type: 'VideoObject',
})

/**
 * Describes a volume mount from a host to container.
 */
export interface VolumeMount extends Thing {
  type: 'VolumeMount'
  mountDestination: String
  mountOptions?: Array<String>
  mountSource?: String
  mountType?: String
}

/**
 * Create a `VolumeMount` node
 * @param props Object containing VolumeMount schema properties as key/value pairs
 * @returns {VolumeMount} VolumeMount schema node
 */
export const volumeMount = (props: Omit<VolumeMount, 'type'>): VolumeMount => ({
  ...compact(props),
  type: 'VolumeMount',
})

/**
 * Union type for valid block content.
 */
export type BlockContent =
  | Claim
  | CodeBlock
  | CodeChunk
  | Collection
  | Figure
  | Heading
  | Include
  | List
  | MathBlock
  | Paragraph
  | QuoteBlock
  | Table
  | ThematicBreak

/**
 * All type schemas that are derived from CodeExecutable
 */
export type CodeExecutableTypes = CodeExecutable | CodeChunk | CodeExpression

/**
 * All type schemas that are derived from Code
 */
export type CodeTypes =
  | Code
  | CodeBlock
  | CodeChunk
  | CodeExecutable
  | CodeExpression
  | CodeFragment

/**
 * All type schemas that are derived from ContactPoint
 */
export type ContactPointTypes = ContactPoint | PostalAddress

/**
 * All type schemas that are derived from CreativeWork
 */
export type CreativeWorkTypes =
  | CreativeWork
  | Article
  | AudioObject
  | Claim
  | Collection
  | Comment
  | Datatable
  | Figure
  | ImageObject
  | MediaObject
  | Periodical
  | PublicationIssue
  | PublicationVolume
  | Review
  | SoftwareApplication
  | SoftwareSourceCode
  | Table
  | VideoObject

/**
 * All type schemas that are derived from Entity
 */
export type EntityTypes =
  | Entity
  | ArrayValidator
  | Article
  | AudioObject
  | BooleanValidator
  | Brand
  | CitationIntentEnumeration
  | Cite
  | CiteGroup
  | Claim
  | Code
  | CodeBlock
  | CodeChunk
  | CodeError
  | CodeExecutable
  | CodeExpression
  | CodeFragment
  | Collection
  | Comment
  | ConstantValidator
  | ContactPoint
  | CreativeWork
  | Datatable
  | DatatableColumn
  | Date
  | DefinedTerm
  | Delete
  | Emphasis
  | EnumValidator
  | Enumeration
  | Figure
  | Function
  | Grant
  | Heading
  | ImageObject
  | Include
  | IntegerValidator
  | Link
  | List
  | ListItem
  | Mark
  | Math
  | MathBlock
  | MathFragment
  | MediaObject
  | MonetaryGrant
  | NontextualAnnotation
  | Note
  | NumberValidator
  | Organization
  | Paragraph
  | Parameter
  | Periodical
  | Person
  | PostalAddress
  | Product
  | PropertyValue
  | PublicationIssue
  | PublicationVolume
  | Quote
  | QuoteBlock
  | Review
  | SoftwareApplication
  | SoftwareEnvironment
  | SoftwareSession
  | SoftwareSourceCode
  | StringValidator
  | Strong
  | Subscript
  | Superscript
  | Table
  | TableCell
  | TableRow
  | ThematicBreak
  | Thing
  | TupleValidator
  | Validator
  | Variable
  | VideoObject
  | VolumeMount

/**
 * All type schemas that are derived from Enumeration
 */
export type EnumerationTypes = Enumeration | CitationIntentEnumeration

/**
 * All type schemas that are derived from Grant
 */
export type GrantTypes = Grant | MonetaryGrant

/**
 * Union type for valid inline content.
 */
export type InlineContent =
  | AudioObject
  | Cite
  | CiteGroup
  | CodeExpression
  | CodeFragment
  | Delete
  | Emphasis
  | ImageObject
  | Link
  | MathFragment
  | NontextualAnnotation
  | Note
  | Parameter
  | Quote
  | Strong
  | Subscript
  | Superscript
  | VideoObject
  | Null
  | Boolean
  | Integer
  | Number
  | String

/**
 * All type schemas that are derived from Mark
 */
export type MarkTypes =
  | Mark
  | Delete
  | Emphasis
  | NontextualAnnotation
  | Quote
  | Strong
  | Subscript
  | Superscript

/**
 * All type schemas that are derived from Math
 */
export type MathTypes = Math | MathBlock | MathFragment

/**
 * All type schemas that are derived from MediaObject
 */
export type MediaObjectTypes =
  | MediaObject
  | AudioObject
  | ImageObject
  | VideoObject

/**
 * Union type for all schema nodes, including primitives and entities
 */
export type Node =
  | Entity
  | ArrayValidator
  | Article
  | AudioObject
  | BooleanValidator
  | Brand
  | CitationIntentEnumeration
  | Cite
  | CiteGroup
  | Claim
  | Code
  | CodeBlock
  | CodeChunk
  | CodeError
  | CodeExecutable
  | CodeExpression
  | CodeFragment
  | Collection
  | Comment
  | ConstantValidator
  | ContactPoint
  | CreativeWork
  | Datatable
  | DatatableColumn
  | Date
  | DefinedTerm
  | Delete
  | Emphasis
  | EnumValidator
  | Enumeration
  | Figure
  | Function
  | Grant
  | Heading
  | ImageObject
  | Include
  | IntegerValidator
  | Link
  | List
  | ListItem
  | Mark
  | Math
  | MathBlock
  | MathFragment
  | MediaObject
  | MonetaryGrant
  | NontextualAnnotation
  | Note
  | NumberValidator
  | Organization
  | Paragraph
  | Parameter
  | Periodical
  | Person
  | PostalAddress
  | Product
  | PropertyValue
  | PublicationIssue
  | PublicationVolume
  | Quote
  | QuoteBlock
  | Review
  | SoftwareApplication
  | SoftwareEnvironment
  | SoftwareSession
  | SoftwareSourceCode
  | StringValidator
  | Strong
  | Subscript
  | Superscript
  | Table
  | TableCell
  | TableRow
  | ThematicBreak
  | Thing
  | TupleValidator
  | Validator
  | Variable
  | VideoObject
  | VolumeMount
  | Null
  | Boolean
  | Integer
  | Number
  | String
  | Object
  | Array<unknown>

/**
 * All type schemas that are derived from Thing
 */
export type ThingTypes =
  | Thing
  | Article
  | AudioObject
  | Brand
  | CitationIntentEnumeration
  | Claim
  | Collection
  | Comment
  | ContactPoint
  | CreativeWork
  | Datatable
  | DatatableColumn
  | DefinedTerm
  | Enumeration
  | Figure
  | Grant
  | ImageObject
  | ListItem
  | MediaObject
  | MonetaryGrant
  | Organization
  | Periodical
  | Person
  | PostalAddress
  | Product
  | PropertyValue
  | PublicationIssue
  | PublicationVolume
  | Review
  | SoftwareApplication
  | SoftwareEnvironment
  | SoftwareSession
  | SoftwareSourceCode
  | Table
  | VideoObject
  | VolumeMount

/**
 * All type schemas that are derived from Validator
 */
export type ValidatorTypes =
  | Validator
  | ArrayValidator
  | BooleanValidator
  | ConstantValidator
  | EnumValidator
  | IntegerValidator
  | NumberValidator
  | StringValidator
  | TupleValidator

/**
 * The type or nature of a citation, both factually and rhetorically.
 */
export enum CitationIntentEnumeration {
  /**
   * The citing entity agrees with statements, ideas or conclusions presented in the cited entity
   */
  AgreesWith = 'AgreesWith',

  /**
   * The citing entity cites the cited entity as one that provides an authoritative description or definition of the subject under discussion
   */
  CitesAsAuthority = 'CitesAsAuthority',

  /**
   * The citing entity cites the cited entity as source of data
   */
  CitesAsDataSource = 'CitesAsDataSource',

  /**
   * The citing entity cites the cited entity as source of factual evidence for statements it contains
   */
  CitesAsEvidence = 'CitesAsEvidence',

  /**
   * The citing entity cites the cited entity as being the container of metadata describing the citing entity
   */
  CitesAsMetadataDocument = 'CitesAsMetadataDocument',

  /**
   * The citing entity cites the cited entity as providing or containing a possible solution to the issues being discussed
   */
  CitesAsPotentialSolution = 'CitesAsPotentialSolution',

  /**
   * The citing entity cites the cited entity as an item of recommended reading
   */
  CitesAsRecommendedReading = 'CitesAsRecommendedReading',

  /**
   * The citing entity cites the cited entity as one that is related
   */
  CitesAsRelated = 'CitesAsRelated',

  /**
   * The citing entity cites the cited entity as being the entity from which the citing entity is derived, or about which the citing entity contains metadata
   */
  CitesAsSourceDocument = 'CitesAsSourceDocument',

  /**
   * The citing entity cites the cited entity as a source of information on the subject under discussion
   */
  CitesForInformation = 'CitesForInformation',

  /**
   * The citing entity is used to create or compile the cited entity
   */
  Compiles = 'Compiles',

  /**
   * The citing entity confirms facts, ideas or statements presented in the cited entity
   */
  Confirms = 'Confirms',

  /**
   * The citing entity contains a statement of fact or a logical assertion (or a collection of such facts and/or assertions) originally present in the cited entity
   */
  ContainsAssertionFrom = 'ContainsAssertionFrom',

  /**
   * The citing entity corrects statements, ideas or conclusions presented in the cited entity
   */
  Corrects = 'Corrects',

  /**
   * The citing entity acknowledges contributions made by the cited entity
   */
  Credits = 'Credits',

  /**
   * The citing entity critiques statements, ideas or conclusions presented in the cited entity
   */
  Critiques = 'Critiques',

  /**
   * The citing entity express derision for the cited entity, or for ideas or conclusions contained within it
   */
  Derides = 'Derides',

  /**
   * The citing entity describes the cited entity
   */
  Describes = 'Describes',

  /**
   * The citing entity disagrees with statements, ideas or conclusions presented in the cited entity
   */
  DisagreesWith = 'DisagreesWith',

  /**
   * The citing entity discusses statements, ideas or conclusions presented in the cited entity
   */
  Discusses = 'Discusses',

  /**
   * The citing entity disputes statements, ideas or conclusions presented in the cited entity
   */
  Disputes = 'Disputes',

  /**
   * The citing entity documents information about the cited entity
   */
  Documents = 'Documents',

  /**
   * The citing entity extends facts, ideas or understandings presented in the cited entity
   */
  Extends = 'Extends',

  /**
   * The cited entity provides background information for the citing entity
   */
  GivesBackgroundTo = 'GivesBackgroundTo',

  /**
   * The cited entity provides intellectual or factual support for the citing entity
   */
  GivesSupportTo = 'GivesSupportTo',

  /**
   * The cited entity evokes a reply from the citing entity
   */
  HasReplyFrom = 'HasReplyFrom',

  /**
   * The citing entity includes one or more excerpts from the cited entity
   */
  IncludesExcerptFrom = 'IncludesExcerptFrom',

  /**
   * The citing entity includes one or more quotations from the cited entity
   */
  IncludesQuotationFrom = 'IncludesQuotationFrom',

  /**
   * The cited entity contains statements, ideas or conclusions with which the citing entity agrees
   */
  IsAgreedWithBy = 'IsAgreedWithBy',

  /**
   * The cited entity is cited as providing an authoritative description or definition of the subject under discussion in the citing entity
   */
  IsCitedAsAuthorityBy = 'IsCitedAsAuthorityBy',

  /**
   * The cited entity is cited as a data source by the citing entity
   */
  IsCitedAsDataSourceBy = 'IsCitedAsDataSourceBy',

  /**
   * The cited entity is cited for providing factual evidence to the citing entity
   */
  IsCitedAsEvidenceBy = 'IsCitedAsEvidenceBy',

  /**
   * The cited entity is cited as being the container of metadata relating to the citing entity
   */
  IsCitedAsMetadataDocumentBy = 'IsCitedAsMetadataDocumentBy',

  /**
   * The cited entity is cited as providing or containing a possible solution to the issues being discussed in the citing entity
   */
  IsCitedAsPontentialSolutionBy = 'IsCitedAsPontentialSolutionBy',

  /**
   * The cited entity is cited by the citing entity as an item of recommended reading
   */
  IsCitedAsRecommendedReadingBy = 'IsCitedAsRecommendedReadingBy',

  /**
   * The cited entity is cited as being related to the citing entity
   */
  IsCitedAsRelatedBy = 'IsCitedAsRelatedBy',

  /**
   * The cited entity is cited as being the entity from which the citing entity is derived, or about which the citing entity contains metadata
   */
  IsCitedAsSourceDocumentBy = 'IsCitedAsSourceDocumentBy',

  /**
   * The cited entity (the subject of the RDF triple) is cited by the citing entity (the object of the triple)
   */
  IsCitedBy = 'IsCitedBy',

  /**
   * The cited entity is cited as a source of information on the subject under discussion in the citing entity
   */
  IsCitedForInformationBy = 'IsCitedForInformationBy',

  /**
   * The cited entity is the result of a compile or creation event using the citing entity
   */
  IsCompiledBy = 'IsCompiledBy',

  /**
   * The cited entity presents facts, ideas or statements that are confirmed by the citing entity
   */
  IsConfirmedBy = 'IsConfirmedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are corrected by the citing entity
   */
  IsCorrectedBy = 'IsCorrectedBy',

  /**
   * The cited entity makes contributions that are acknowledged by the citing entity
   */
  IsCreditedBy = 'IsCreditedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are critiqued by the citing entity
   */
  IsCritiquedBy = 'IsCritiquedBy',

  /**
   * The cited entity contains ideas or conclusions for which the citing entity express derision
   */
  IsDeridedBy = 'IsDeridedBy',

  /**
   * The cited entity is described by the citing entity
   */
  IsDescribedBy = 'IsDescribedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are disagreed with by the citing entity
   */
  IsDisagreedWithBy = 'IsDisagreedWithBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are discussed by the citing entity
   */
  IsDiscussedBy = 'IsDiscussedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are disputed by the citing entity
   */
  IsDisputedBy = 'IsDisputedBy',

  /**
   * Information about the cited entity is documented by the citing entity
   */
  IsDocumentedBy = 'IsDocumentedBy',

  /**
   * The cited entity presents facts, ideas or understandings that are extended by the citing entity
   */
  IsExtendedBy = 'IsExtendedBy',

  /**
   * The cited entity is the target for an HTTP Uniform Resource Locator (URL) link within the citing entity
   */
  IsLinkedToBy = 'IsLinkedToBy',

  /**
   * The characteristic style or content of the cited entity is imitated by the citing entity for comic effect, usually without explicit citation
   */
  IsParodiedBy = 'IsParodiedBy',

  /**
   * The cited entity is plagiarized by the author of the citing entity, who includes within the citing entity textual or other elements from the cited entity without formal acknowledgement of their source
   */
  IsPlagiarizedBy = 'IsPlagiarizedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are qualified or have conditions placed upon them by the citing entity
   */
  IsQualifiedBy = 'IsQualifiedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are refuted by the citing entity
   */
  IsRefutedBy = 'IsRefutedBy',

  /**
   * The cited entity is formally retracted by the citing entity
   */
  IsRetractedBy = 'IsRetractedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are reviewed by the citing entity
   */
  IsReviewedBy = 'IsReviewedBy',

  /**
   * The cited entity or aspects of its contents are ridiculed by the citing entity
   */
  IsRidiculedBy = 'IsRidiculedBy',

  /**
   * The cited entity is cited because the citing article contains speculations on its content or ideas
   */
  IsSpeculatedOnBy = 'IsSpeculatedOnBy',

  /**
   * The cited entity receives intellectual or factual support from the citing entity
   */
  IsSupportedBy = 'IsSupportedBy',

  /**
   * The cited entity presents statements, ideas, hypotheses or understanding that are updated by the cited entity
   */
  IsUpdatedBy = 'IsUpdatedBy',

  /**
   * A property that permits you to express appreciation of or interest in something that is the object of the RDF triple, or to express that it is worth thinking about even if you do not agree with its content, enabling social media 'likes' statements to be encoded in RDF
   */
  Likes = 'Likes',

  /**
   * The citing entity provides a link, in the form of an HTTP Uniform Resource Locator (URL), to the cited entity
   */
  LinksTo = 'LinksTo',

  /**
   * The citing entity obtains background information from the cited entity
   */
  ObtainsBackgroundFrom = 'ObtainsBackgroundFrom',

  /**
   * The citing entity obtains intellectual or factual support from the cited entity
   */
  ObtainsSupportFrom = 'ObtainsSupportFrom',

  /**
   * The citing entity imitates the characteristic style or content of the cited entity for comic effect, usually without explicit citation
   */
  Parodies = 'Parodies',

  /**
   * A property indicating that the author of the citing entity plagiarizes the cited entity, by including textual or other elements from the cited entity without formal acknowledgement of their source
   */
  Plagiarizes = 'Plagiarizes',

  /**
   * The cited entity contains and is the original source of a statement of fact or a logical assertion (or a collection of such facts and/or assertions) that is to be found in the citing entity
   */
  ProvidesAssertionFor = 'ProvidesAssertionFor',

  /**
   * The cited entity presents conclusions that are used in work described in the citing entity
   */
  ProvidesConclusionsFor = 'ProvidesConclusionsFor',

  /**
   * The cited entity presents data that are used in work described in the citing entity
   */
  ProvidesDataFor = 'ProvidesDataFor',

  /**
   * The cited entity contains information, usually of a textual nature, that is excerpted by (used as an excerpt within) the citing entity
   */
  ProvidesExcerptFor = 'ProvidesExcerptFor',

  /**
   * The cited entity details a method that is used in work described by the citing entity
   */
  ProvidesMethodFor = 'ProvidesMethodFor',

  /**
   * The cited entity contains information, usually of a textual nature, that is quoted by (used as a quotation within) the citing entity
   */
  ProvidesQuotationFor = 'ProvidesQuotationFor',

  /**
   * The citing entity qualifies or places conditions or restrictions upon statements, ideas or conclusions presented in the cited entity
   */
  Qualifies = 'Qualifies',

  /**
   * The citing entity refutes statements, ideas or conclusions presented in the cited entity
   */
  Refutes = 'Refutes',

  /**
   * The citing entity replies to statements, ideas or criticisms presented in the cited entity
   */
  RepliesTo = 'RepliesTo',

  /**
   * The citing entity constitutes a formal retraction of the cited entity
   */
  Retracts = 'Retracts',

  /**
   * The citing entity reviews statements, ideas or conclusions presented in the cited entity
   */
  Reviews = 'Reviews',

  /**
   * The citing entity ridicules the cited entity or aspects of its contents
   */
  Ridicules = 'Ridicules',

  /**
   * Each entity has at least one author that shares a common institutional affiliation with an author of the other entity
   */
  SharesAuthorInstitutionWith = 'SharesAuthorInstitutionWith',

  /**
   * Each entity has at least one author in common with the other entity
   */
  SharesAuthorWith = 'SharesAuthorWith',

  /**
   * The two entities result from activities that have been funded by the same funding agency
   */
  SharesFundingAgencyWith = 'SharesFundingAgencyWith',

  /**
   * The citing and cited bibliographic resources are published in the same journal
   */
  SharesJournalWith = 'SharesJournalWith',

  /**
   * The citing and cited bibliographic resources are published in same publication venue
   */
  SharesPublicationVenueWith = 'SharesPublicationVenueWith',

  /**
   * The citing entity speculates on something within or related to the cited entity, without firm evidence
   */
  SpeculatesOn = 'SpeculatesOn',

  /**
   * The citing entity provides intellectual or factual support for statements, ideas or conclusions presented in the cited entity
   */
  Supports = 'Supports',

  /**
   * The citing entity updates statements, ideas, hypotheses or understanding presented in the cited entity
   */
  Updates = 'Updates',

  /**
   * The citing entity describes work that uses conclusions presented in the cited entity
   */
  UsesConclusionsFrom = 'UsesConclusionsFrom',

  /**
   * The citing entity describes work that uses data presented in the cited entity
   */
  UsesDataFrom = 'UsesDataFrom',

  /**
   * The citing entity describes work that uses a method detailed in the cited entity
   */
  UsesMethodIn = 'UsesMethodIn',
}

export type TypeMap<T extends Entity = Entity> = { [key in T['type']]: key }

export const codeExecutableTypes: TypeMap<
  Exclude<CodeExecutableTypes, Primitives>
> = {
  CodeExecutable: 'CodeExecutable',
  CodeChunk: 'CodeChunk',
  CodeExpression: 'CodeExpression',
}
export const codeTypes: TypeMap<Exclude<CodeTypes, Primitives>> = {
  Code: 'Code',
  CodeBlock: 'CodeBlock',
  CodeChunk: 'CodeChunk',
  CodeExecutable: 'CodeExecutable',
  CodeExpression: 'CodeExpression',
  CodeFragment: 'CodeFragment',
}
export const contactPointTypes: TypeMap<
  Exclude<ContactPointTypes, Primitives>
> = {
  ContactPoint: 'ContactPoint',
  PostalAddress: 'PostalAddress',
}
export const creativeWorkTypes: TypeMap<
  Exclude<CreativeWorkTypes, Primitives>
> = {
  CreativeWork: 'CreativeWork',
  Article: 'Article',
  AudioObject: 'AudioObject',
  Claim: 'Claim',
  Collection: 'Collection',
  Comment: 'Comment',
  Datatable: 'Datatable',
  Figure: 'Figure',
  ImageObject: 'ImageObject',
  MediaObject: 'MediaObject',
  Periodical: 'Periodical',
  PublicationIssue: 'PublicationIssue',
  PublicationVolume: 'PublicationVolume',
  Review: 'Review',
  SoftwareApplication: 'SoftwareApplication',
  SoftwareSourceCode: 'SoftwareSourceCode',
  Table: 'Table',
  VideoObject: 'VideoObject',
}
export const entityTypes: TypeMap<Exclude<EntityTypes, Primitives>> = {
  Entity: 'Entity',
  ArrayValidator: 'ArrayValidator',
  Article: 'Article',
  AudioObject: 'AudioObject',
  BooleanValidator: 'BooleanValidator',
  Brand: 'Brand',
  CitationIntentEnumeration: 'CitationIntentEnumeration',
  Cite: 'Cite',
  CiteGroup: 'CiteGroup',
  Claim: 'Claim',
  Code: 'Code',
  CodeBlock: 'CodeBlock',
  CodeChunk: 'CodeChunk',
  CodeError: 'CodeError',
  CodeExecutable: 'CodeExecutable',
  CodeExpression: 'CodeExpression',
  CodeFragment: 'CodeFragment',
  Collection: 'Collection',
  Comment: 'Comment',
  ConstantValidator: 'ConstantValidator',
  ContactPoint: 'ContactPoint',
  CreativeWork: 'CreativeWork',
  Datatable: 'Datatable',
  DatatableColumn: 'DatatableColumn',
  Date: 'Date',
  DefinedTerm: 'DefinedTerm',
  Delete: 'Delete',
  Emphasis: 'Emphasis',
  EnumValidator: 'EnumValidator',
  Enumeration: 'Enumeration',
  Figure: 'Figure',
  Function: 'Function',
  Grant: 'Grant',
  Heading: 'Heading',
  ImageObject: 'ImageObject',
  Include: 'Include',
  IntegerValidator: 'IntegerValidator',
  Link: 'Link',
  List: 'List',
  ListItem: 'ListItem',
  Mark: 'Mark',
  Math: 'Math',
  MathBlock: 'MathBlock',
  MathFragment: 'MathFragment',
  MediaObject: 'MediaObject',
  MonetaryGrant: 'MonetaryGrant',
  NontextualAnnotation: 'NontextualAnnotation',
  Note: 'Note',
  NumberValidator: 'NumberValidator',
  Organization: 'Organization',
  Paragraph: 'Paragraph',
  Parameter: 'Parameter',
  Periodical: 'Periodical',
  Person: 'Person',
  PostalAddress: 'PostalAddress',
  Product: 'Product',
  PropertyValue: 'PropertyValue',
  PublicationIssue: 'PublicationIssue',
  PublicationVolume: 'PublicationVolume',
  Quote: 'Quote',
  QuoteBlock: 'QuoteBlock',
  Review: 'Review',
  SoftwareApplication: 'SoftwareApplication',
  SoftwareEnvironment: 'SoftwareEnvironment',
  SoftwareSession: 'SoftwareSession',
  SoftwareSourceCode: 'SoftwareSourceCode',
  StringValidator: 'StringValidator',
  Strong: 'Strong',
  Subscript: 'Subscript',
  Superscript: 'Superscript',
  Table: 'Table',
  TableCell: 'TableCell',
  TableRow: 'TableRow',
  ThematicBreak: 'ThematicBreak',
  Thing: 'Thing',
  TupleValidator: 'TupleValidator',
  Validator: 'Validator',
  Variable: 'Variable',
  VideoObject: 'VideoObject',
  VolumeMount: 'VolumeMount',
}
export const enumerationTypes: TypeMap<Exclude<EnumerationTypes, Primitives>> =
  {
    Enumeration: 'Enumeration',
    CitationIntentEnumeration: 'CitationIntentEnumeration',
  }
export const grantTypes: TypeMap<Exclude<GrantTypes, Primitives>> = {
  Grant: 'Grant',
  MonetaryGrant: 'MonetaryGrant',
}
export const markTypes: TypeMap<Exclude<MarkTypes, Primitives>> = {
  Mark: 'Mark',
  Delete: 'Delete',
  Emphasis: 'Emphasis',
  NontextualAnnotation: 'NontextualAnnotation',
  Quote: 'Quote',
  Strong: 'Strong',
  Subscript: 'Subscript',
  Superscript: 'Superscript',
}
export const mathTypes: TypeMap<Exclude<MathTypes, Primitives>> = {
  Math: 'Math',
  MathBlock: 'MathBlock',
  MathFragment: 'MathFragment',
}
export const mediaObjectTypes: TypeMap<Exclude<MediaObjectTypes, Primitives>> =
  {
    MediaObject: 'MediaObject',
    AudioObject: 'AudioObject',
    ImageObject: 'ImageObject',
    VideoObject: 'VideoObject',
  }
export const thingTypes: TypeMap<Exclude<ThingTypes, Primitives>> = {
  Thing: 'Thing',
  Article: 'Article',
  AudioObject: 'AudioObject',
  Brand: 'Brand',
  CitationIntentEnumeration: 'CitationIntentEnumeration',
  Claim: 'Claim',
  Collection: 'Collection',
  Comment: 'Comment',
  ContactPoint: 'ContactPoint',
  CreativeWork: 'CreativeWork',
  Datatable: 'Datatable',
  DatatableColumn: 'DatatableColumn',
  DefinedTerm: 'DefinedTerm',
  Enumeration: 'Enumeration',
  Figure: 'Figure',
  Grant: 'Grant',
  ImageObject: 'ImageObject',
  ListItem: 'ListItem',
  MediaObject: 'MediaObject',
  MonetaryGrant: 'MonetaryGrant',
  Organization: 'Organization',
  Periodical: 'Periodical',
  Person: 'Person',
  PostalAddress: 'PostalAddress',
  Product: 'Product',
  PropertyValue: 'PropertyValue',
  PublicationIssue: 'PublicationIssue',
  PublicationVolume: 'PublicationVolume',
  Review: 'Review',
  SoftwareApplication: 'SoftwareApplication',
  SoftwareEnvironment: 'SoftwareEnvironment',
  SoftwareSession: 'SoftwareSession',
  SoftwareSourceCode: 'SoftwareSourceCode',
  Table: 'Table',
  VideoObject: 'VideoObject',
  VolumeMount: 'VolumeMount',
}
export const validatorTypes: TypeMap<Exclude<ValidatorTypes, Primitives>> = {
  Validator: 'Validator',
  ArrayValidator: 'ArrayValidator',
  BooleanValidator: 'BooleanValidator',
  ConstantValidator: 'ConstantValidator',
  EnumValidator: 'EnumValidator',
  IntegerValidator: 'IntegerValidator',
  NumberValidator: 'NumberValidator',
  StringValidator: 'StringValidator',
  TupleValidator: 'TupleValidator',
}
export const blockContentTypes: TypeMap<Exclude<BlockContent, Primitives>> = {
  Claim: 'Claim',
  CodeBlock: 'CodeBlock',
  CodeChunk: 'CodeChunk',
  Collection: 'Collection',
  Figure: 'Figure',
  Heading: 'Heading',
  Include: 'Include',
  List: 'List',
  MathBlock: 'MathBlock',
  Paragraph: 'Paragraph',
  QuoteBlock: 'QuoteBlock',
  Table: 'Table',
  ThematicBreak: 'ThematicBreak',
}
export const inlineContentTypes: TypeMap<Exclude<InlineContent, Primitives>> = {
  AudioObject: 'AudioObject',
  Cite: 'Cite',
  CiteGroup: 'CiteGroup',
  CodeExpression: 'CodeExpression',
  CodeFragment: 'CodeFragment',
  Delete: 'Delete',
  Emphasis: 'Emphasis',
  ImageObject: 'ImageObject',
  Link: 'Link',
  MathFragment: 'MathFragment',
  NontextualAnnotation: 'NontextualAnnotation',
  Note: 'Note',
  Parameter: 'Parameter',
  Quote: 'Quote',
  Strong: 'Strong',
  Subscript: 'Subscript',
  Superscript: 'Superscript',
  VideoObject: 'VideoObject',
}

export interface Unions {
  CodeExecutableTypes: CodeExecutableTypes
  CodeTypes: CodeTypes
  ContactPointTypes: ContactPointTypes
  CreativeWorkTypes: CreativeWorkTypes
  EntityTypes: EntityTypes
  EnumerationTypes: EnumerationTypes
  GrantTypes: GrantTypes
  MarkTypes: MarkTypes
  MathTypes: MathTypes
  MediaObjectTypes: MediaObjectTypes
  ThingTypes: ThingTypes
  ValidatorTypes: ValidatorTypes
  BlockContent: BlockContent
  InlineContent: InlineContent
}

export const unions = {
  CodeExecutableTypes: codeExecutableTypes,
  CodeTypes: codeTypes,
  ContactPointTypes: contactPointTypes,
  CreativeWorkTypes: creativeWorkTypes,
  EntityTypes: entityTypes,
  EnumerationTypes: enumerationTypes,
  GrantTypes: grantTypes,
  MarkTypes: markTypes,
  MathTypes: mathTypes,
  MediaObjectTypes: mediaObjectTypes,
  ThingTypes: thingTypes,
  ValidatorTypes: validatorTypes,
  BlockContent: blockContentTypes,
  InlineContent: inlineContentTypes,
}
