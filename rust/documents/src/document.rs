use std::{
    env,
    fmt::Debug,
    fs,
    ops::Deref,
    path::{Path, PathBuf},
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    },
    time::{Duration, Instant},
};

use notify::DebouncedEvent;

use codecs::EncodeOptions;
use common::{
    async_recursion::async_recursion,
    eyre::{bail, Result},
    serde::Serialize,
    serde_json::{self, json},
    strum::Display,
    tokio::{
        self,
        sync::{broadcast, mpsc, Mutex, RwLock},
        task::JoinHandle,
    },
    tracing,
};
use events::{publish, Event, SubscriptionId, SubscriptionTopic};
use formats::FormatSpec;
use graph::{Graph, PlanScope};
use graph_triples::{Relations, TagMap};
use kernels::{KernelInfos, KernelSpace, KernelSymbols};
use node_patch::{diff, merge, Patch};
use node_pointer::find;
use node_reshape::reshape;
use providers::DetectItem;
use stencila_schema::{Article, Node};

use crate::messages::{
    CancelRequest, CompileRequest, ExecuteRequest, PatchRequest, Request, RequestId, Response,
    When, WriteRequest,
};

/// The status of a document with respect to on-disk synchronization
#[derive(Debug, Clone, Serialize, Display)]
#[serde(rename_all = "lowercase", crate = "common::serde")]
#[strum(serialize_all = "lowercase")]
enum DocumentStatus {
    /// The document `content` is the same as on disk at its `path`.
    Synced,
    /// The document `content` has modifications that have not yet
    /// been written to its `path`.
    Unwritten,
    /// The document `path` has modifications that have not yet
    /// been read into its `content`.
    Unread,
    /// The document `path` no longer exists and is now set to `None`.
    /// The user will need to choose a new path for the document if they
    /// want to save it.
    Deleted,
}

/// The version of a document
pub type DocumentVersion = Arc<AtomicU64>;

/// The root node of a document
pub type DocumentRoot = Arc<RwLock<Node>>;

/// A channel sender/receiver for events to a document's listen task
pub type DocumentEventSender = mpsc::UnboundedSender<Event>;
pub type DocumentEventReceiver = mpsc::UnboundedReceiver<Event>;

/// A function that listens to pub-sub topics and generates a task request in response
pub type DocumentEventListener = fn(topic: &str, detail: serde_json::Value) -> Request;

/// The set of document listeners and the pub-sub topics that they are listening to
pub type DocumentEventListeners = Arc<
    RwLock<(
        Vec<(String, SubscriptionTopic, DocumentEventListener)>,
        Vec<(SubscriptionTopic, SubscriptionId)>,
    )>,
>;

// Channel sender/receivers for document tasks

pub type DocumentPatchRequestSender = mpsc::UnboundedSender<PatchRequest>;
pub type DocumentPatchRequestReceiver = mpsc::UnboundedReceiver<PatchRequest>;

pub type DocumentCompileRequestSender = mpsc::Sender<CompileRequest>;
pub type DocumentCompileRequestReceiver = mpsc::Receiver<CompileRequest>;

pub type DocumentExecuteRequestSender = mpsc::Sender<ExecuteRequest>;
pub type DocumentExecuteRequestReceiver = mpsc::Receiver<ExecuteRequest>;

pub type DocumentCancelRequestSender = mpsc::Sender<CancelRequest>;
pub type DocumentCancelRequestReceiver = mpsc::Receiver<CancelRequest>;

pub type DocumentWriteRequestSender = mpsc::UnboundedSender<WriteRequest>;
pub type DocumentWriteRequestReceiver = mpsc::UnboundedReceiver<WriteRequest>;

pub type DocumentResponseSender = broadcast::Sender<Response>;
pub type DocumentResponseReceiver = broadcast::Receiver<Response>;

/// An in-memory representation of a document
#[derive(Serialize)]
#[serde(crate = "common::serde")]
pub struct Document {
    /// The document identifier
    pub id: String,

    /// The absolute path of the document's file.
    pub path: PathBuf,

    /// The project directory for this document.
    ///
    /// Used to restrict file links (e.g. image paths) to within
    /// the project for both security and reproducibility reasons.
    /// For documents opened from within a project, this will be project directory.
    /// For "orphan" documents (opened by themselves) this will be the
    /// parent directory of the document. When the document is compiled,
    /// an error will be returned if a file link is outside of the root.
    project: PathBuf,

    /// Whether or not the document's file is in the temporary
    /// directory.
    temporary: bool,

    /// The synchronization status of the document.
    /// This is orthogonal to `temporary` because a document's
    /// `content` can be synced or un-synced with the file system
    /// regardless of whether or not its `path` is temporary..
    status: DocumentStatus,

    /// The last time that the document was written to disk.
    ///
    /// Used to ignore file modification notification events generated by
    /// this application itself.
    #[serde(skip)]
    last_write: Arc<RwLock<Instant>>,

    /// The name of the document
    ///
    /// Usually the filename from the `path` but "Untitled"
    /// for temporary documents.
    name: String,

    /// The format of the document.
    ///
    /// On initialization, this is inferred, if possible, from the file name extension
    /// of the document's `path`. However, it may change whilst the document is
    /// open in memory (e.g. if the `load` function sets a different format).
    pub(crate) format: FormatSpec,

    /// Whether a HTML preview of the document is supported
    ///
    /// This is determined by the type of the `root` node of the document.
    /// Will be `true` if the `root` is a type for which HTML previews are
    /// implemented e.g. `Article`, `ImageObject` and `false` if the `root`
    /// is `None`, or of some other type e.g. `Entity`.
    ///
    /// This flag is intended for dynamically determining whether to open
    /// a preview panel for a document by default. Regardless of its value,
    /// a user should be able to open a preview panel, in HTML or some other
    /// format, for any document.
    previewable: bool,

    /// The current UTF8 string content of the document.
    ///
    /// When a document is `read()` from a file the `content` is the content
    /// of the file. The `content` may subsequently be changed using
    /// the `load()` function. A call to `write()` will write the content
    /// back to `path`.
    ///
    /// Skipped during serialization because will often be large.
    #[serde(skip)]
    pub(crate) content: String,

    /// The version of the document
    ///
    /// Is incremented in the `patch_task` and can be read using the `version()` method
    version: DocumentVersion,

    /// The root Stencila Schema node of the document
    ///
    /// Can be any type of `Node` but defaults to an empty `Article`.
    ///
    /// A [`RwLock`] to enable separate, concurrent tasks to read (e.g. for dumping to some
    /// format) and write (e.g. to apply patches from clients) the node.
    ///
    /// Skipped during serialization because will often be large.
    #[serde(skip)]
    pub(crate) root: DocumentRoot,

    /// Global tags defined in any of the document's code chunks
    #[allow(dead_code)]
    #[serde(skip)]
    tags: Arc<RwLock<TagMap>>,

    /// The kernel space for this document.
    ///
    /// This is where document variables are stored and executable nodes such as
    /// `CodeChunk`s and `Parameters`s are executed.
    #[serde(skip)]
    kernels: Arc<RwLock<KernelSpace>>,

    /// The set of dependency relations between this document, or nodes in this document,
    /// and other resources.
    ///
    /// Relations may be external (e.g. the document links to another `Resource::File`),
    /// or internal (e.g. the second code chunk uses a `Resource::Symbol` defined in the
    /// first code chunk).
    ///
    /// Stored for use in building the project's graph, but that may be removed
    /// in the future. Not serialized since this information is in `self.graph`.
    #[serde(skip)]
    pub relations: Relations,

    /// The document's dependency graph
    ///
    /// This is derived from `relations`.
    #[serde(skip)]
    pub(crate) graph: Arc<RwLock<Graph>>,

    #[serde(skip)]
    pub(crate) patch_request_sender: DocumentPatchRequestSender,

    #[serde(skip)]
    pub(crate) compile_request_sender: DocumentCompileRequestSender,

    #[serde(skip)]
    pub(crate) execute_request_sender: DocumentExecuteRequestSender,

    #[serde(skip)]
    pub(crate) cancel_request_sender: DocumentCancelRequestSender,

    // TODO: Add `write_request` method and refactor `write` method similar to
    // `patch_request`, `patch` etc.
    #[allow(dead_code)]
    #[serde(skip)]
    pub(crate) write_request_sender: DocumentWriteRequestSender,

    #[serde(skip)]
    pub(crate) response_receiver: DocumentResponseReceiver,
}

impl Debug for Document {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Document {}", self.id)
    }
}

#[allow(unused)]
impl Document {
    /// Milliseconds debounce delay for [`When::Soon`] compile requests
    pub(crate) const COMPILE_DEBOUNCE_MILLIS: u64 = 250;

    /// Milliseconds debounce delay for [`When::Soon`] execute requests
    pub(crate) const EXECUTE_DEBOUNCE_MILLIS: u64 = 750;

    /// Milliseconds debounce delay for [`When::Soon`] write requests
    pub(crate) const WRITE_DEBOUNCE_MILLIS: u64 = 1000;

    /// Milliseconds after writing document to ignore other events on its file
    pub(crate) const WRITE_MUTE_MILLIS: u64 = 500;

    /// Create a new empty document.
    ///
    /// # Arguments
    ///
    /// - `path`: The path of the document; defaults to a temporary path.
    /// - `format`: The format of the document; defaults to plain text.
    ///
    /// This function is intended to be used by editors when creating
    /// a new document. If the `path` is not specified, the created document
    /// will be `temporary: true` and have a temporary file path.
    #[tracing::instrument]
    fn new(path: Option<PathBuf>, format: Option<String>) -> Result<Document> {
        let id = suids::generate("do").to_string();

        let format = if let Some(format) = format {
            formats::match_path(&format)
        } else if let Some(path) = path.as_ref() {
            formats::match_path(path)
        } else {
            formats::match_name("txt")
        }
        .spec();
        let previewable = format.preview;

        let (path, name, temporary) = match path {
            Some(path) => {
                let name = path
                    .file_name()
                    .map(|os_str| os_str.to_string_lossy())
                    .unwrap_or_else(|| "Untitled".into())
                    .into();

                let path = path.canonicalize()?;

                (path, name, false)
            }
            None => {
                let path = env::temp_dir().join(
                    [
                        suids::generate("fi").to_string(),
                        ".".to_string(),
                        format.extension.clone(),
                    ]
                    .concat(),
                );
                // Ensure that the file exists
                if !path.exists() {
                    fs::write(path.clone(), "").expect("Unable to write temporary file");
                }

                let name = "Untitled".into();

                (path, name, true)
            }
        };

        let project = path
            .parent()
            .expect("Unable to get path parent")
            .to_path_buf();

        let version = DocumentVersion::default();
        let root = Arc::new(RwLock::new(Node::Article(Article::default())));
        let tags = Arc::new(RwLock::new(TagMap::default()));
        let graph = Arc::new(RwLock::new(Graph::default()));
        let kernels = Arc::new(RwLock::new(KernelSpace::new(Some(&project))));
        let event_listeners = DocumentEventListeners::default();
        let last_write = Arc::new(RwLock::new(Instant::now()));

        let (
            patch_request_sender,
            compile_request_sender,
            execute_request_sender,
            cancel_request_sender,
            write_request_sender,
            response_receiver,
        ) = Self::initialize(
            &id,
            &path,
            &project,
            &format,
            &version,
            &root,
            &tags,
            &graph,
            &kernels,
            &event_listeners,
            &last_write,
        );

        Ok(Document {
            id,
            path,
            project,
            temporary,
            name,
            format,
            previewable,

            status: DocumentStatus::Synced,
            last_write,
            content: Default::default(),

            version,
            root,
            tags,
            graph,
            kernels,

            relations: Default::default(),

            patch_request_sender,
            compile_request_sender,
            execute_request_sender,
            cancel_request_sender,
            write_request_sender,
            response_receiver,
        })
    }

    #[async_recursion]
    pub async fn fork(&self) -> Result<Document> {
        let id = suids::generate("do").to_string();
        let path = self.path.clone();
        let project = self.project.clone();
        let format = self.format.clone();

        tracing::debug!(
            "Forking document `{}` from `{}` to `{}`",
            self.id,
            self.path.display(),
            id
        );

        // Fields that can be cloned

        let version = DocumentVersion::new(AtomicU64::new(self.version.load(Ordering::Acquire)));
        let root = Arc::new(RwLock::new(self.root.read().await.clone()));
        let tags = Arc::new(RwLock::new(self.tags.read().await.clone()));
        let graph = Arc::new(RwLock::new(self.graph.read().await.clone()));

        // Fields that need to be forked

        let (kernels, kernels_restarted) = self.kernels.read().await.fork().await?;
        let kernels = Arc::new(RwLock::new(kernels));

        let event_listeners = DocumentEventListeners::default();
        let last_write = Arc::new(RwLock::new(Instant::now()));

        let (
            patch_request_sender,
            compile_request_sender,
            execute_request_sender,
            cancel_request_sender,
            write_request_sender,
            response_receiver,
        ) = Self::initialize(
            &id,
            &path,
            &project,
            &format,
            &version,
            &root,
            &tags,
            &graph,
            &kernels,
            &event_listeners,
            &last_write,
        );

        Ok(Document {
            id,
            path,
            project,
            temporary: self.temporary,
            name: self.name.clone(),
            format,
            previewable: self.previewable,

            status: DocumentStatus::Synced,
            last_write,
            content: Default::default(),

            version,
            root,
            tags,
            graph,
            kernels,

            relations: Default::default(),

            patch_request_sender,
            compile_request_sender,
            execute_request_sender,
            cancel_request_sender,
            write_request_sender,
            response_receiver,
        })
    }

    /// Create a new document, optionally with content.
    pub async fn create<P: AsRef<Path>>(
        path: Option<P>,
        content: Option<String>,
        format: Option<String>,
    ) -> Result<Document> {
        let path = path.map(|path| PathBuf::from(path.as_ref()));

        let mut document = Document::new(path, format)?;
        if let Some(content) = content {
            document.load(content, None).await?;
        }

        Ok(document)
    }

    /// Open a document from an existing file.
    ///
    /// # Arguments
    ///
    /// - `path`: The path of the file to create the document from
    ///
    /// - `format`: The format of the document. If `None` will be inferred from
    ///             the path's file extension.
    #[tracing::instrument(skip(path))]
    pub async fn open<P: AsRef<Path>>(path: P, format: Option<String>) -> Result<Document> {
        let path = path.as_ref();
        let path = Self::find_matching_path(path, None)?;

        let mut document = Document::new(Some(path.clone()), format)?;
        if let Err(error) = document.read(true).await {
            tracing::warn!("While reading document `{}`: {}", path.display(), error)
        };

        Ok(document)
    }

    /// Alter properties of the document
    ///
    /// # Arguments
    ///
    /// - `path`: The path of document's file
    ///
    /// - `format`: The format of the document. If `None` will be inferred from
    ///             the path's file extension.
    #[tracing::instrument(skip(self, path))]
    pub async fn alter<P: AsRef<Path>>(
        &mut self,
        path: Option<P>,
        format: Option<String>,
    ) -> Result<()> {
        if let Some(path) = &path {
            let path = path.as_ref().canonicalize()?;

            if path.is_dir() {
                bail!("Can not open a folder as a document; maybe try opening it as a project instead.")
            }

            self.project = path
                .parent()
                .expect("Unable to get path parent")
                .to_path_buf();

            self.name = path
                .file_name()
                .map(|os_str| os_str.to_string_lossy())
                .unwrap_or_else(|| "Untitled".into())
                .into();

            self.path = path;
            self.temporary = false;
            self.status = DocumentStatus::Unwritten;
        }

        if let Some(format) = format {
            self.format = formats::match_path(&format).spec();
        } else if let Some(path) = path {
            self.format = formats::match_path(&path).spec();
        };

        self.previewable = self.format.preview;

        // Given that the `format` may have changed, it is necessary
        // to update the `root` of the document
        self.update(true).await?;

        Ok(())
    }

    /// Read the document from the file system, update it and return its content.
    ///
    /// # Arguments
    ///
    /// - `force_load`: if `false` then if the file is empty, or is the same as the existing
    ///                 content then do not load the content into the document
    ///
    /// Using `force_load: false` is recommended when calling this function in response to
    /// file modification events as writes in quick succession can cause the file to be momentarily
    /// empty when read.
    ///
    /// Sets `status` to `Synced`. For binary files, does not actually read the content
    /// but will update the document nonetheless (possibly delegating the actual read
    /// to a binary or plugin)
    #[tracing::instrument(skip(self))]
    pub async fn read(&mut self, force_load: bool) -> Result<String> {
        let content = if !self.format.binary {
            let content = fs::read_to_string(&self.path)?;
            if force_load || (!content.is_empty() && content != self.content) {
                self.load(content.clone(), None).await?;
            }
            content
        } else {
            self.update(true).await?;
            "".to_string()
        };
        self.status = DocumentStatus::Synced;
        Ok(content)
    }

    /// Write the document to the file system, optionally load new `content`
    /// and set `format` before doing so.
    ///
    /// # Arguments
    ///
    /// - `content`: the content to load into the document
    /// - `format`: the format of the content; if not supplied assumed to be
    ///    the document's existing format.
    ///
    /// Sets `status` to `Synced`.
    #[tracing::instrument(skip(self, content))]
    pub async fn write(&mut self, content: Option<String>, format: Option<String>) -> Result<()> {
        if let Some(content) = content {
            self.load(content, format.clone()).await?;
        }

        let content_to_write = if let Some(input_format) = format.as_ref() {
            let input_format = formats::match_path(&input_format).spec();
            if input_format != self.format {
                self.dump(None, None, None).await?
            } else {
                self.content.clone()
            }
        } else {
            self.content.clone()
        };

        fs::write(&self.path, content_to_write.as_bytes())?;
        self.status = DocumentStatus::Synced;
        *self.last_write.write().await = Instant::now();

        Ok(())
    }

    /// Write the document to the file system, as an another file, possibly in
    /// another format.
    ///
    /// # Arguments
    ///
    /// - `path`: the path for the new file.
    /// - `format`: the format to dump the content as; if not supplied assumed to be
    ///    the document's existing format.
    /// - `theme`: theme to apply to the new document (HTML and PDF only).
    ///
    /// Note: this does not change the `path`, `format` or `status` of the current
    /// document.
    #[tracing::instrument(skip(self, path))]
    pub async fn write_as<P: AsRef<Path>>(
        &self,
        path: P,
        format: Option<String>,
        theme: Option<String>,
    ) -> Result<()> {
        let path = path.as_ref();

        let format = format.unwrap_or_else(|| {
            path.extension().map_or_else(
                || self.format.extension.clone(),
                |ext| ext.to_string_lossy().to_string(),
            )
        });

        let mut options = codecs::EncodeOptions {
            standalone: true,
            theme,
            ..Default::default()
        };

        let root = &*self.root.read().await;
        codecs::to_path(root, path, Some(&format), Some(options)).await?;

        Ok(())
    }

    /// A background task to write the document to its path on request
    ///
    /// # Arguments
    ///
    /// - `root`: The root [`Node`] to write (will be read locked)
    ///
    /// - `path`: The filesystem path to write to
    ///
    /// - `format`: The format to write (defaults to the path extension)
    ///
    /// - `request_receiver`: The channel to receive [`WriteRequest`]s on
    ///
    /// - `response_sender`: The channel to send a [`Response`] on when each request if fulfilled
    pub(crate) async fn write_task(
        root: &DocumentRoot,
        last_write: &Arc<RwLock<Instant>>,
        path: &Path,
        format: Option<&str>,
        request_receiver: &mut DocumentWriteRequestReceiver,
        response_sender: &DocumentResponseSender,
    ) {
        let duration = Duration::from_millis(Document::WRITE_DEBOUNCE_MILLIS);
        let mut write = false;
        loop {
            match tokio::time::timeout(duration, request_receiver.recv()).await {
                // Request received: record and continue to wait for timeout unless `when` is now
                Ok(Some(request)) => {
                    write = true;
                    if !matches!(request.when, When::Now) {
                        continue;
                    }
                }
                // Sender dropped: end of task
                Ok(None) => break,
                // Timeout so do the following with the last unhandled request, if any
                Err(..) => {}
            };

            if write {
                tracing::trace!("Writing document to `{}`", path.display());
                if let Err(error) =
                    codecs::to_path(root.read().await.deref(), path, format, None).await
                {
                    tracing::error!("While writing to `{}`: {}", path.display(), error);
                }

                *last_write.write().await = Instant::now();
                write = false;
            }
        }
    }

    /// Dump the document's content to a string in its current, or
    /// alternative, format.
    ///
    /// # Arguments
    ///
    /// - `format`: the format to dump the content as; if not supplied assumed to be
    ///    the document's existing format.
    ///
    /// - `node_id`: the id of the node within the document to dump
    ///
    /// - `options`: any encoding options
    #[tracing::instrument(skip(self))]
    pub async fn dump(
        &self,
        format: Option<String>,
        node_id: Option<String>,
        options: Option<EncodeOptions>,
    ) -> Result<String> {
        let format = match format {
            Some(format) => format,
            None => return Ok(self.content.clone()),
        };

        let root = &*self.root.read().await;
        if let Some(node_id) = node_id {
            let pointer = find(root, &node_id)?;
            let node = pointer.to_node()?;
            codecs::to_string(&node, &format, options).await
        } else {
            codecs::to_string(root, &format, options).await
        }
    }

    /// Load content into the document
    ///
    /// If the format of the new content is different to the document's format
    /// then the content will be converted to the document's format.
    ///
    /// # Arguments
    ///
    /// - `content`: the content to load into the document
    /// - `format`: the format of the content; if not supplied assumed to be
    ///    the document's existing format.
    #[tracing::instrument(skip(self, content))]
    pub async fn load(&mut self, content: String, format: Option<String>) -> Result<()> {
        let mut decode_content = true;
        if let Some(format) = format {
            let other_format = formats::match_path(&format).spec();
            if other_format != self.format {
                let node = codecs::from_str(&content, &other_format.extension, None).await?;
                if !self.format.binary {
                    self.content = codecs::to_string(&node, &self.format.extension, None).await?;
                }
                let mut root = &mut *self.root.write().await;
                *root = node;
                decode_content = false;
            } else {
                self.content = content;
            }
        } else {
            self.content = content;
        };
        self.status = DocumentStatus::Unwritten;

        self.update(decode_content).await
    }

    /// Generate a [`Patch`] describing the operations needed to modify this
    /// document so that it is equal to another.
    #[tracing::instrument(skip(self, other))]
    pub async fn diff(&self, other: &Document) -> Result<Patch> {
        let me = &*self.root.read().await;
        let other = &*other.root.read().await;
        let patch = diff(me, other);
        Ok(patch)
    }

    /// Merge changes from two or more derived version into this document.
    ///
    /// See documentation on the [`merge`] function for how any conflicts
    /// are resolved.
    #[tracing::instrument(skip(self, deriveds))]
    pub async fn merge(&mut self, deriveds: &[Document]) -> Result<()> {
        let mut guard = self.root.write().await;

        // Need to store `let` bindings to read guards before dereferencing them
        let mut guards = Vec::new();
        for derived in deriveds {
            let guard = derived.root.read().await;
            guards.push(guard)
        }
        let others: Vec<&Node> = guards.iter().map(|guard| guard.deref()).collect();

        // Do the merge into root
        merge(&mut *guard, &others);

        // TODO updating of *content from root* and publishing of events etc needs to be sorted out
        if !self.format.binary {
            self.content = codecs::to_string(&*guard, &self.format.extension, None).await?;
        }

        // Drop root guard to allow update
        drop(guard);

        self.update(false).await?;

        Ok(())
    }

    /// Get the version of the document
    pub fn version(&self) -> u64 {
        self.version.load(Ordering::Acquire)
    }

    /// Restart a kernel (or all kernels) in the document's kernel space
    ///
    /// Cancels any execution plan that is running, destroy the document's
    /// existing kernel, and create's a new one
    #[tracing::instrument(skip(self))]
    pub async fn restart(&self, kernel_id: Option<String>) -> Result<()> {
        tracing::debug!("Restarting kernel/s for document `{}`", self.id);

        self.cancel(None, Some(PlanScope::All)).await;

        let kernels = &*self.kernels.write().await;
        kernels.restart(kernel_id).await?;

        Ok(())
    }

    /// Get the list of kernels in the document's kernel space
    pub async fn kernels(&self) -> KernelInfos {
        let kernel_space = &*self.kernels.read().await;
        kernel_space.kernels().await
    }

    /// Get the list of symbols in the document's kernel space
    pub async fn symbols(&self) -> KernelSymbols {
        let kernel_space = &*self.kernels.read().await;
        kernel_space.symbols().await
    }

    /// Update the `root` (and associated properties) of the document and publish updated encodings
    ///
    /// Publishes `encoded:` events for each of the formats subscribed to.
    /// Error results from this function (e.g. compile errors)
    /// should generally not be bubbled up.
    ///
    /// # Arguments
    ///
    /// - `decode_content`: Should the current content of the be decoded?. This
    ///                     is an optimization for situations where the `root` has
    ///                     just been decoded from the current `content`.
    #[tracing::instrument(skip(self))]
    async fn update(&mut self, decode_content: bool) -> Result<()> {
        tracing::debug!(
            "Updating document `{}` at `{}`",
            self.id,
            self.path.display()
        );

        // Decode the binary file or, in-memory content into the `root` node
        // of the document
        let format = &self.format.extension;
        let mut root = if self.format.binary {
            if self.path.exists() {
                tracing::debug!("Decoding document `{}` root from path", self.id);
                codecs::from_path(&self.path, Some(format), None).await?
            } else {
                self.root.read().await.clone()
            }
        } else if !self.content.is_empty() {
            if decode_content {
                tracing::debug!("Decoding document `{}` root from content", self.id);
                codecs::from_str(&self.content, format, None).await?
            } else {
                self.root.read().await.clone()
            }
        } else {
            tracing::debug!("Setting document `{}` root to empty article", self.id);
            Node::Article(Article::default())
        };

        // Reshape the `root`
        // TODO: Pass user options for reshaping through
        reshape(&mut root, None)?;

        // Determine if the document is preview-able, based on the type of the root
        // This list of types should be updated as HTML encoding is implemented for each.
        self.previewable = matches!(
            root,
            Node::Article(..)
                | Node::ImageObject(..)
                | Node::AudioObject(..)
                | Node::VideoObject(..)
        );

        // Set the root, and compile
        // TODO: Reconsider this in refactoring of alternative format representations of docs
        *self.root.write().await = root;
        self.compile(When::Never, When::Never, None).await?;

        Ok(())
    }

    /// Detect entities within the document
    pub async fn detect(&self) -> Result<Vec<DetectItem>> {
        let root = &*self.root.read().await;
        providers::detect(root).await
    }

    /// Generate a topic string for the document
    pub fn topic(&self, subtopic: &str) -> String {
        ["documents:", &self.id, ":", subtopic].concat()
    }

    /// Publish an event for this document
    fn publish<Detail: Serialize>(&self, subtopic: &str, detail: Detail) {
        publish(&self.topic(subtopic), detail)
    }

    /// Called when the file is removed from the file system
    ///
    /// Sets `status` to `Deleted` and publishes a `Deleted` event so that,
    /// for example, a document's tab can be updated to indicate it is deleted.
    fn deleted(&mut self, path: PathBuf) {
        tracing::debug!(
            "Deleted event for document `{}` at `{}`",
            self.id,
            path.display()
        );

        self.status = DocumentStatus::Deleted;

        self.publish("deleted", path)
    }

    /// Called when the file is renamed
    ///
    /// Changes the `path` and publishes a `Renamed` event so that, for example,
    /// a document's tab can be updated with the new file name.
    #[allow(dead_code)]
    fn renamed(&mut self, from: PathBuf, to: PathBuf) {
        tracing::debug!(
            "Renamed event for document `{}`: `{}` to `{}`",
            self.id,
            from.display(),
            to.display()
        );

        // If the document has been moved out of its project then we need to reassign `project`
        // (to ensure that files in the old project can not be linked to).
        if to.strip_prefix(&self.project).is_err() {
            self.project = match to.parent() {
                Some(path) => path.to_path_buf(),
                None => to.clone(),
            }
        }

        self.path = to.clone();

        self.publish("renamed", json!({"from": from, "to": to}))
    }

    /// Called when the file is modified
    ///
    /// Reads the file into `content` and emits a `Modified` event so that the user
    /// can be asked if they want to load the new content into editor, or overwrite with
    /// existing editor content.
    ///
    /// Will ignore any events within a small duration of `write()` being called to avoid
    /// reacting to file modifications initiated by this process
    async fn modified(&mut self, path: PathBuf) {
        if self.last_write.read().await.elapsed() < Duration::from_millis(Self::WRITE_MUTE_MILLIS) {
            return;
        }

        tracing::debug!(
            "Modified event for document `{}` at `{}`",
            self.id,
            path.display()
        );

        self.status = DocumentStatus::Unread;

        match self.read(false).await {
            Ok(content) => self.publish("modified", content),
            Err(error) => tracing::error!("While attempting to read modified file: {}", error),
        }
    }
}

#[derive(Debug)]
pub struct DocumentHandler {
    /// The document being handled.
    pub(crate) document: Arc<Mutex<Document>>,

    /// The event handler thread's join handle.
    ///
    /// Held so that when this handler is dropped, the
    /// event handler thread is aborted.
    handler: Option<JoinHandle<()>>,
}

impl Clone for DocumentHandler {
    fn clone(&self) -> Self {
        DocumentHandler {
            document: self.document.clone(),
            handler: None,
        }
    }
}

impl Drop for DocumentHandler {
    fn drop(&mut self) {
        match &self.handler {
            Some(handler) => handler.abort(),
            None => {}
        }
    }
}

impl DocumentHandler {
    /// Create a new document handler.
    ///
    /// # Arguments
    ///
    /// - `document`: The document that this handler is for.
    /// - `watch`: Whether to watch the document (e.g. not for temporary, new files)
    pub(crate) fn new(document: Document, watch: bool) -> DocumentHandler {
        let id = document.id.clone();
        let path = document.path.clone();

        let document = Arc::new(Mutex::new(document));
        let handler = if watch {
            let handler = DocumentHandler::watch(id, path, Arc::clone(&document));
            Some(handler)
        } else {
            None
        };

        DocumentHandler { document, handler }
    }

    const WATCHER_DELAY_MILLIS: u64 = 100;

    /// Watch the document.
    ///
    /// It is necessary to have a file watcher that is separate from a project directory watcher
    /// for documents that are opened independent of a project (a.k.a. orphan documents).
    ///
    /// It is also necessary for this watcher to be on the parent folder of the document
    /// (which, for some documents may be concurrent with the watcher for the project) and to filter
    /// events related to the file. That is necessary because some events are otherwise
    /// not captured e.g. file renames (delete and then create) and file writes by some software
    /// (e.g. LibreOffice deletes and then creates a file instead of just writing it).
    fn watch(id: String, path: PathBuf, document: Arc<Mutex<Document>>) -> JoinHandle<()> {
        let (async_sender, mut async_receiver) = tokio::sync::mpsc::channel(100);

        let path_cloned = path.clone();

        // Standard thread to run blocking sync file watcher
        std::thread::spawn(move || -> Result<()> {
            use notify::{watcher, RecursiveMode, Watcher};

            let (watcher_sender, watcher_receiver) = std::sync::mpsc::channel();
            let mut watcher = watcher(
                watcher_sender,
                Duration::from_millis(DocumentHandler::WATCHER_DELAY_MILLIS),
            )?;
            let parent = path.parent().unwrap_or(&path);
            watcher.watch(&parent, RecursiveMode::NonRecursive)?;

            // Event checking timeout. Can be quite long since only want to check
            // whether we can end this thread.
            let timeout = Duration::from_millis(100);

            let path_string = path.display().to_string();
            let span = tracing::info_span!("document_watch", path = path_string.as_str());
            let _enter = span.enter();
            tracing::trace!(
                "Starting document watcher for '{}' at '{}'",
                id,
                path_string
            );
            loop {
                // Check for an event. Use `recv_timeout` so we don't
                // get stuck here and will do following check that ends this
                // thread if the owning `DocumentHandler` is dropped
                if let Ok(event) = watcher_receiver.recv_timeout(timeout) {
                    if let Err(error) = async_sender.blocking_send(event) {
                        tracing::debug!(
                            "While sending file watch event watcher for document '{}': {}",
                            id,
                            error
                        );
                        break;
                    }
                }
            }
            tracing::trace!("Ending document watcher for '{}' at '{}'", id, path_string);

            // Drop the sync send so that the event handling thread also ends
            drop(async_sender);

            Ok(())
        });

        // Async task to handle events
        tokio::spawn(async move {
            let mut document_path = path_cloned;
            tracing::trace!("Starting document handler");
            while let Some(event) = async_receiver.recv().await {
                match event {
                    DebouncedEvent::Create(path) | DebouncedEvent::Write(path) => {
                        let doc = &mut *document.lock().await;
                        if path == document_path {
                            doc.modified(path.clone()).await
                        }
                    }
                    DebouncedEvent::Remove(path) => {
                        let doc = &mut *document.lock().await;
                        if path == document_path {
                            doc.deleted(path)
                        }
                    }
                    DebouncedEvent::Rename(from, to) => {
                        let doc = &mut *document.lock().await;
                        if from == document_path {
                            document_path = to.clone();
                            doc.renamed(from, to)
                        }
                    }
                    _ => {}
                }
            }
            // Because we abort this thread, this entry may never get
            // printed (only if the `async_sender` is dropped before this is aborted)
            tracing::trace!("Ending document handler");
        })
    }
}
