///! Stencila unique identifiers.
///!
///! The identifiers generated by this module:
///!
///! - are URL safe
///! - contain information on the type of object that they are identifying
///! - have an extremely low probability of collision
///!
///! By default, generated identifiers have a fixed length of 23 characters made up
///! of two parts separated by an underscore:
///!
///! - 2 characters in the range `[a-z]` that identifying the "family" of
///!   identifiers, usually the type of object the identifier is for
///!   e.g. `fi` = file, `re` = request
///!
///! - 20 characters in the range `[0-9A-Za-z]` that are randomly generated
///!
///! For project identifiers (those starting with 'pr') only lowercase
///! letters are used for compatibility with Docker image naming rules.
///!
///! The default size of 23 bytes allows ids to fit inside a [`SmartString`](https://lib.rs/crates/smartstring)
///! for better performance (particularly for `HashMap` lookups) than a plain old `String`.
use nanoid::nanoid;
use smartstring::{Compact, SmartString};

use common::{
    eyre::{bail, Result},
    regex::Regex,
};

pub use common;

pub type Suid = SmartString<Compact>;

/// The separator between the family and random parts of the identifier
///
/// An underscore is used, rather than say a hyphen, for better copy/paste compatibility.
const SEPARATOR: &str = "_";

/// The characters used in the random part of the identifier
const CHARACTERS: [char; 62] = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
    'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',
    'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
    'V', 'W', 'X', 'Y', 'Z',
];

/// Create a family of UUIDs
///
/// ```
/// use suids::suid_family;
///
/// suid_family!(MyId, "my");
/// let id = MyId::new();
/// ```
#[macro_export]
macro_rules! suid_family {
    ($name:ident, $prefix:literal) => {
        #[derive(
            Debug, Clone, suids::common::serde::Deserialize, suids::common::serde::Serialize,
        )]
        #[serde(crate = "suids::common::serde")]
        pub struct $name(suids::Suid);

        impl $name {
            pub fn new() -> Self {
                Self(suids::generate($prefix))
            }
        }

        impl Default for $name {
            fn default() -> Self {
                Self::new()
            }
        }

        impl std::fmt::Display for $name {
            fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "{}", self.0.to_string())
            }
        }

        impl std::cmp::PartialEq for $name {
            fn eq(&self, other: &Self) -> bool {
                self.0 == other.0
            }
        }

        impl std::cmp::Eq for $name {}

        impl std::cmp::PartialOrd for $name {
            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                self.0.partial_cmp(&other.0)
            }
        }

        impl std::cmp::Ord for $name {
            fn cmp(&self, other: &Self) -> std::cmp::Ordering {
                self.0.cmp(&other.0)
            }
        }

        impl std::hash::Hash for $name {
            fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                self.0.hash(state);
            }
        }

        impl std::ops::Deref for $name {
            type Target = suids::Suid;

            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }

        impl std::convert::TryFrom<&str> for $name {
            type Error = suids::InvalidSuid;

            fn try_from(id: &str) -> std::result::Result<Self, Self::Error> {
                match suids::matches($prefix, id) {
                    true => Ok($name(id.into())),
                    false => Err(suids::InvalidSuid {}),
                }
            }
        }
    };
}

pub struct InvalidSuid;

// Generate a universally unique identifier
pub fn generate(prefix: &str) -> Suid {
    let chars = nanoid!(20, &CHARACTERS);
    [prefix, SEPARATOR, &chars].concat().into()
}

// Generate a universally unique identifier with only lowercase letters and digits
pub fn generate_lower(prefix: &str) -> Suid {
    let chars = nanoid!(20, &CHARACTERS[..36]);
    [prefix, SEPARATOR, &chars].concat().into()
}

// Generate a universally unique identifier with a specific number of random characters
pub fn generate_num(prefix: &str, num: usize) -> Suid {
    let chars = nanoid!(num, &CHARACTERS);
    [prefix, SEPARATOR, &chars].concat().into()
}

// Test whether a string is an identifier for a particular prefix
pub fn matches(prefix: &str, id: &str) -> bool {
    let re = ["^", prefix, SEPARATOR, "[0-9a-zA-Z]{20}$"].concat();
    let re = Regex::new(&re).expect("Should be a valid regex");
    re.is_match(id)
}

// Assert that a `Suid` is an identifier for a particular family
pub fn assert(family: &str, id: Suid) -> Result<Suid> {
    match matches(family, &id) {
        true => Ok(id),
        false => bail!(
            "Invalid UUID `{}`, family does not match `{}`",
            family.to_string(),
            id
        ),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn normal() {
        let id = generate("no");
        assert_eq!(id.len(), 23);
        assert!(matches("no", &id));
        assert("no", id).unwrap();
    }

    #[test]
    fn lower() {
        let id = generate_lower("pr");
        assert_eq!(id.len(), 23);
        assert!(matches("pr", &id));
        assert("pr", id).unwrap();
    }
}
