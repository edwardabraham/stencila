---
source: rust/src/methods/encode/ipynb.rs
expression: json
input_file: fixtures/articles/kitchen-sink.ipynb

---
{
  "cells": [
    {
      "cell_type": "markdown",
      "source": [
        "# Introduction\n",
        "\n",
        "This is a “kitchen sink” test fixture for the Jupyter Notebook (`ipynb`) format. It’s principal use is in testing Stencila’s conversion to / from Jupyter Notebooks but also serves to document that conversion. It contains a variety of document node types and Jupyter cell types.\n",
        "\n",
        "# Meta data\n",
        "\n",
        "Stencila parses the `metadata` property of a notebook by coercing it to an `Article`. This allows article properties such as `title`, `authors`, `funders` and `references` to be encoded into the `ipynb` format and then extracted, for conversion to other formats e.g. HTML.\n",
        "\n",
        "# Markdown cells\n",
        "\n",
        "This Markdown cell illustrates that Stencila supports the same Markdown syntax (including extensions) in Jupyter Notebooks, as in plain Markdown files.\n",
        "\n",
        "Including inline node types like _emphasis_, **strong emphasis**, ~~delete~~, super^script^, and sub~script~.\n",
        "\n",
        "- Also lists\n",
        "- like this\n",
        "\n",
        "> And block quotes like this\n",
        "> \n",
        "> \n",
        "\n",
        "Markdown cells get decoded into arrays of `BlockContent` and merged together, so the the fact that this cell is separate from the preceding and following cells will not be apparent.\n",
        "\n",
        "# Code expressions\n",
        "\n",
        "Stencila supports inline executable code expressions and variable interpolation using either:\n",
        "\n",
        "- the `exec` keyword on backticked inline code e.g. `1+1`{python exec}, optionally with a language e.g. `2*2`{r exec}.\n",
        "- double curly braces `3+3`{python exec}, optionally with a language `4+4`{r exec}.\n",
        "\n",
        "Using backticks with `exec` is recommend as most Markdown parsers will properly escape symbols like `*` within backticks. If code expressions do not specify a language, then Stencila falls back to the language of the notebook e.g. `4*4`{python exec} and `5+5`{python exec}.\n",
        "\n",
        "# Code chunks\n",
        "\n",
        "Jupyter code cells are converted into Stencila `CodeChunk`s.\n",
        "\n",
        "## Cell languages\n",
        "\n",
        "All cells in a notebook normally all use the same language. However, if a cell has a `language_info.name` specified in their `metadata` property then Stencila will use that, rather than the language from the top-level metadata of the notebook.\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Python"
      ],
      "outputs": [],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "// JavaScript"
      ],
      "outputs": [],
      "metadata": {
        "language_info": {
          "name": "javascript"
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "The following code cells illustrate how different types of cell outputs are decoded.\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# No output"
      ],
      "outputs": [],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Primitive outputs\n",
        "\n",
        "Stencila will attempt to parse the `text/plain` outputs of cells (including stream outputs) into node types such as `Boolean`, `Number`, `Array`, `Object` etc, falling back to `String`.\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Plain text output\n",
        "\"Hello world\""
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "Hello world"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "True"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "true"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "False"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "false"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "42"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "42"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "import math\n",
        "math.pi"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "3.141592653589793"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "dict(a=1,b=2)"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{\"a\":1,\"b\":2}"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "list(range(10))"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "[0,1,2,3,4,5,6,7,8,9]"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "dict(a='string', b=1, c=3.14, d=[1, 2, 3], e=dict(f=1))"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{\"a\":\"string\",\"b\":1,\"c\":3.14,\"d\":[1,2,3],\"e\":{\"f\":1}}"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Stream output\n",
        "print(\"Just a string\")"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "Just a string\n"
            ]
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Image outputs\n",
        "\n",
        "Stencila supports several image formats, including dynamic formats such as Plotly and Altair (Vega/Vega-Lite).\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Matplotlib\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "x = np.linspace(0, 10, 100)\n",
        "plt.plot(x, np.sin(x))\n",
        "plt.show()"
      ],
      "outputs": [
        {
          "output_type": "display_data",
          "data": {},
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Plotly\n",
        "import plotly.express as px\n",
        "fig = px.scatter(px.data.iris(), x=\"sepal_width\", y=\"sepal_length\")\n",
        "fig.show()\n"
      ],
      "outputs": [
        {
          "output_type": "display_data",
          "data": {},
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Altair\n",
        "import altair as alt\n",
        "import pandas as pd\n",
        "\n",
        "alt.renderers.enable('mimetype')\n",
        "\n",
        "source = pd.DataFrame({\n",
        "    'a': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'],\n",
        "    'b': [28, 55, 43, 91, 81, 53, 19, 87, 52]\n",
        "})\n",
        "\n",
        "alt.Chart(source).mark_bar().encode(\n",
        "    x='a',\n",
        "    y='b'\n",
        ")"
      ],
      "outputs": [
        {
          "output_type": "display_data",
          "data": {},
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## HTML outputs\n",
        "\n",
        "Stencila will attempt to convert `text/html` outputs into rich node types e.g. `Table`\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "\n",
        "df = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), columns=['a', 'b', 'c'])\n",
        "\n",
        "# By default a `text/html` representation of the data frame is generated\n",
        "df"
      ],
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": []
          },
          "metadata": {}
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Preformatted text outputs\n",
        "\n",
        "If a string output of the cell includes newlines, tabs or more than two consecutive spaces (other than leading or trailing whitespace) it is treated as preformatted text and converted to a Stencila `CodeBlock`.\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Print the data.frame so that is output as `text/plain`\n",
        "print(df)"
      ],
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": "   a  b  c\n0  1  2  3\n1  4  5  6\n2  7  8  9\n"
        }
      ],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Errors\n",
        "\n",
        "Stencila converts any cell outputs that are errors into a `CodeError` with message, type and stack trace. In addition, any output to the `stderr` stream is converted to a `CodeError` with `errorType: \"stderr\"`.\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "A syntax error"
      ],
      "outputs": [],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "foo()"
      ],
      "outputs": [],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "import sys\n",
        "print(\"Whooaah!\", file=sys.stderr)"
      ],
      "outputs": [],
      "metadata": {
        "language_info": {
          "name": "python"
        }
      }
    }
  ],
  "metadata": {
    "authors": [
      {
        "type": "Person",
        "emails": [
          "nokome@stenci.la"
        ],
        "familyNames": [
          "Bentley"
        ],
        "givenNames": [
          "Nokome"
        ],
        "name": "Nokome Bentley"
      }
    ],
    "title": "Kitchen sink Jupyter Notebook test fixture"
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
