use common::defaults::Defaults;
use node_address::{Address, Slot};

use crate::{
    operation::{
        Add, AddMany, Copy, Move, Operation, OperationFlag, OperationFlagSet, Remove, RemoveMany,
        Replace, ReplaceMany, Transform,
    },
    patchable::Patchable,
};

/// A differencing `struct` used as an optimization to track the address
/// in a node tree while walking over it and hold diffing options.
#[derive(Defaults)]
pub struct Differ {
    /// The operations that are allowed to generated by this differ
    ///
    /// `Add` and `Remove` operations are always allowed
    #[def = "OperationFlag::all()"]
    pub(crate) ops_allowed: OperationFlagSet,

    /// The number of seconds before diffing operations will timeout
    #[def = "10"]
    pub(crate) timeout: u64,

    /// The current address of the differ in a node tree.
    pub(crate) address: Address,

    /// The operations generated by walking over a node tree.
    pub(crate) ops: Vec<Operation>,
}

impl Differ {
    /// Difference a field of a `struct` or an item of a `HashMap`.
    ///
    /// Adds a `Name` key to `address` and then differences the two values.
    pub fn field<Type: Patchable>(&mut self, name: &str, value1: &Type, value2: &Type) {
        self.enter(Slot::Name(name.to_string()));
        value1.diff(value2, self);
        self.exit();
    }

    /// Difference an item in a `Vec`.
    ///
    /// Adds an `Index` key to `address` and then differences the two values.
    pub fn item<Type: Patchable>(&mut self, index: usize, value1: &Type, value2: &Type) {
        self.enter(Slot::Index(index));
        value1.diff(value2, self);
        self.exit();
    }

    /// Enter a node by pushing a slot onto the differ's address
    pub fn enter(&mut self, slot: Slot) {
        self.address.push_back(slot)
    }

    /// Exit a node by popping a slot off the differ's address
    pub fn exit(&mut self) -> Option<Slot> {
        self.address.pop_back()
    }

    /// Push an operation nested within the current address
    pub fn push(&mut self, op: Operation) {
        let op = match op {
            Operation::Add(Add {
                address,
                value,
                html,
            }) => Operation::Add(Add {
                address: self.address.concat(address),
                value,
                html,
            }),

            Operation::AddMany(AddMany {
                address,
                values,
                html,
            }) => Operation::AddMany(AddMany {
                address: self.address.concat(address),
                values,
                html,
            }),

            Operation::Remove(Remove { address }) => Operation::Remove(Remove {
                address: self.address.concat(address),
            }),

            Operation::RemoveMany(RemoveMany { address, items }) => {
                Operation::RemoveMany(RemoveMany {
                    address: self.address.concat(address),
                    items,
                })
            }

            Operation::Replace(Replace {
                address,
                value,
                html,
            }) => Operation::Replace(Replace {
                address: self.address.concat(address),
                value,
                html,
            }),

            Operation::ReplaceMany(ReplaceMany {
                address,
                items,
                values,
                html,
            }) => Operation::ReplaceMany(ReplaceMany {
                address: self.address.concat(address),
                items,
                values,
                html,
            }),

            Operation::Move(Move { from, to }) => Operation::Move(Move {
                from: self.address.concat(from),
                to: self.address.concat(to),
            }),

            Operation::Copy(Copy { from, to }) => Operation::Copy(Copy {
                from: self.address.concat(from),
                to: self.address.concat(to),
            }),

            Operation::Transform(Transform { address, from, to }) => {
                Operation::Transform(Transform {
                    address: self.address.concat(address),
                    from,
                    to,
                })
            }
        };
        self.ops.push(op)
    }

    pub fn pop(&mut self) -> Option<Operation> {
        self.ops.pop()
    }

    /// Append a list of operations nested within the current address
    pub fn append(&mut self, ops: Vec<Operation>) {
        for op in ops {
            self.push(op)
        }
    }

    /// Add an `Add` operation to the patch.
    pub fn add<P: Patchable>(&mut self, value: &P) {
        self.ops
            .push(Operation::add(self.address.clone(), value.to_value()))
    }

    /// Add a `Remove` operation to the patch.
    pub fn remove(&mut self) {
        self.ops.push(Operation::remove(self.address.clone()))
    }

    /// Add a `Replace` operation to the patch.
    pub fn replace<P: Patchable>(&mut self, value: &P) {
        self.ops
            .push(Operation::replace(self.address.clone(), value.to_value()))
    }

    /// Add a `Transform` operation to the patch.
    pub fn transform(&mut self, from: &str, to: &str) {
        self.ops
            .push(Operation::transform(self.address.clone(), from, to))
    }
}
