use common::defaults::Defaults;
use node_address::{Address, Slot};

use crate::{
    operation::{Add, Copy, Move, Operation, Remove, Replace, Transform},
    patchable::Patchable,
    value::Value,
};

/// A differencing `struct` used as an optimization to track the address describing the
/// current location in a node tree while walking over it.
#[derive(Defaults)]
pub struct Differ {
    /// The list of address describing the current location in a node tree.
    pub(crate) address: Address,

    /// The operations generated by walking over a node tree.
    pub(crate) ops: Vec<Operation>,
}

impl Differ {
    /// Difference a field of a `struct` or an item of a `HashMap`.
    ///
    /// Adds a `Name` key to `address` and then differences the two values.
    pub fn field<Type: Patchable>(&mut self, name: &str, value1: &Type, value2: &Type) {
        self.address.push_back(Slot::Name(name.to_string()));
        value1.diff(value2, self);
        self.address.pop_back();
    }

    /// Difference an item in a `Vec`.
    ///
    /// Adds an `Index` key to `address` and then differences the two values.
    pub fn item<Type: Patchable>(&mut self, index: usize, value1: &Type, value2: &Type) {
        self.address.push_back(Slot::Index(index));
        value1.diff(value2, self);
        self.address.pop_back();
    }

    /// Push an operations nested within the current address
    pub fn push(&mut self, op: Operation) {
        let op = match op {
            Operation::Add(Add {
                address,
                value,
                length,
                html,
            }) => Operation::Add(Add {
                address: self.address.concat(&address),
                value,
                length,
                html,
            }),
            Operation::Remove(Remove { address, items }) => Operation::Remove(Remove {
                address: self.address.concat(&address),
                items,
            }),
            Operation::Replace(Replace {
                address,
                items,
                value,
                length,
                html,
            }) => Operation::Replace(Replace {
                address: self.address.concat(&address),
                items,
                value,
                length,
                html,
            }),
            Operation::Move(Move { from, items, to }) => Operation::Move(Move {
                from: self.address.concat(&from),
                items,
                to: self.address.concat(&to),
            }),
            Operation::Copy(Copy { from, items, to }) => Operation::Copy(Copy {
                from: self.address.concat(&from),
                items,
                to: self.address.concat(&to),
            }),
            Operation::Transform(Transform { address, from, to }) => {
                Operation::Transform(Transform {
                    address: self.address.concat(&address),
                    from,
                    to,
                })
            }
        };
        self.ops.push(op)
    }

    /// Append a list of operations nested within the current address
    pub fn append(&mut self, ops: Vec<Operation>) {
        for op in ops {
            self.push(op)
        }
    }

    /// Add an `Add` operation to the patch.
    pub fn add<Type: Clone + Send + 'static>(&mut self, value: &Type) {
        self.ops.push(Operation::Add(Add {
            address: self.address.clone(),
            value: Value::any(value.clone()),
            length: 1,
            html: None,
        }))
    }

    /// Add a `Remove` operation to the patch.
    pub fn remove(&mut self) {
        self.ops.push(Operation::Remove(Remove {
            address: self.address.clone(),
            items: 1,
        }))
    }

    /// Add a `Replace` operation to the patch.
    pub fn replace<Type: Clone + Send + 'static>(&mut self, value: &Type) {
        self.ops.push(Operation::Replace(Replace {
            address: self.address.clone(),
            items: 1,
            value: Value::any(value.clone()),
            length: 1,
            html: None,
        }))
    }

    /// Add a `Transform` operation to the patch.
    pub fn transform(&mut self, from: &str, to: &str) {
        self.ops.push(Operation::Transform(Transform {
            address: self.address.clone(),
            from: from.into(),
            to: to.into(),
        }))
    }
}
