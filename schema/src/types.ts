/* eslint-disable */

// This file was automatically generated by `typescript.ts`.
// Do not modify it by hand. Instead, modify the source `.schema.yaml` files
// in the `schema` directory and run `npm run build:ts` to regenerate it.

type Integer = number

// Remove properties from an Object if their value is undefined
const compact = <O extends object>(o: O): O =>
  Object.entries(o).reduce(
    (compactedO: O, [k, v]) =>
      v === undefined ? compactedO : { ...compactedO, [k]: v },
    {} as O
  )

export interface Types {
  Array: Array<Primitive>
  ArrayValidator: ArrayValidator
  Article: Article
  AudioObject: AudioObject
  BlockContent: BlockContent
  Boolean: boolean
  BooleanValidator: BooleanValidator
  Brand: Brand
  CitationIntentEnumeration: CitationIntentEnumeration
  Cite: Cite
  CiteGroup: CiteGroup
  Claim: Claim
  Code: Code
  CodeBlock: CodeBlock
  CodeChunk: CodeChunk
  CodeError: CodeError
  CodeExecutable: CodeExecutable
  CodeExecutableTypes: CodeExecutableTypes
  CodeExpression: CodeExpression
  CodeFragment: CodeFragment
  CodeTypes: CodeTypes
  Collection: Collection
  Comment: Comment
  ConstantValidator: ConstantValidator
  ContactPoint: ContactPoint
  ContactPointTypes: ContactPointTypes
  CreativeWork: CreativeWork
  CreativeWorkTypes: CreativeWorkTypes
  Datatable: Datatable
  DatatableColumn: DatatableColumn
  Date: Date
  DefinedTerm: DefinedTerm
  Delete: Delete
  Emphasis: Emphasis
  Entity: Entity
  EntityTypes: EntityTypes
  EnumValidator: EnumValidator
  Enumeration: Enumeration
  EnumerationTypes: EnumerationTypes
  Figure: Figure
  Function: Function
  Grant: Grant
  GrantTypes: GrantTypes
  Heading: Heading
  ImageObject: ImageObject
  Include: Include
  InlineContent: InlineContent
  Integer: Integer
  IntegerValidator: IntegerValidator
  Link: Link
  List: List
  ListItem: ListItem
  Mark: Mark
  MarkTypes: MarkTypes
  Math: Math
  MathBlock: MathBlock
  MathFragment: MathFragment
  MathTypes: MathTypes
  MediaObject: MediaObject
  MediaObjectTypes: MediaObjectTypes
  MonetaryGrant: MonetaryGrant
  Node: Node
  NontextualAnnotation: NontextualAnnotation
  Note: Note
  Null: null
  Number: number
  NumberValidator: NumberValidator
  NumberValidatorTypes: NumberValidatorTypes
  Object: { [property: string]: Primitive }
  Organization: Organization
  Paragraph: Paragraph
  Parameter: Parameter
  Periodical: Periodical
  Person: Person
  PostalAddress: PostalAddress
  Primitive: Primitive
  Product: Product
  PropertyValue: PropertyValue
  PublicationIssue: PublicationIssue
  PublicationVolume: PublicationVolume
  Quote: Quote
  QuoteBlock: QuoteBlock
  Review: Review
  SoftwareApplication: SoftwareApplication
  SoftwareEnvironment: SoftwareEnvironment
  SoftwareSession: SoftwareSession
  SoftwareSourceCode: SoftwareSourceCode
  Strikeout: Strikeout
  String: string
  StringValidator: StringValidator
  Strong: Strong
  Subscript: Subscript
  Superscript: Superscript
  Table: Table
  TableCell: TableCell
  TableRow: TableRow
  ThematicBreak: ThematicBreak
  Thing: Thing
  ThingTypes: ThingTypes
  TupleValidator: TupleValidator
  Underline: Underline
  Validator: Validator
  ValidatorTypes: ValidatorTypes
  Variable: Variable
  VideoObject: VideoObject
  VolumeMount: VolumeMount
}

/**
 * The most simple compound (ie. non-atomic like `number`, `string` etc) type.
 */
export type Entity = {
  type:
    | 'Entity'
    | 'ArrayValidator'
    | 'Article'
    | 'AudioObject'
    | 'BooleanValidator'
    | 'Brand'
    | 'CitationIntentEnumeration'
    | 'Cite'
    | 'CiteGroup'
    | 'Claim'
    | 'Code'
    | 'CodeBlock'
    | 'CodeChunk'
    | 'CodeError'
    | 'CodeExecutable'
    | 'CodeExpression'
    | 'CodeFragment'
    | 'Collection'
    | 'Comment'
    | 'ConstantValidator'
    | 'ContactPoint'
    | 'CreativeWork'
    | 'Datatable'
    | 'DatatableColumn'
    | 'Date'
    | 'DefinedTerm'
    | 'Delete'
    | 'Emphasis'
    | 'EnumValidator'
    | 'Enumeration'
    | 'Figure'
    | 'Function'
    | 'Grant'
    | 'Heading'
    | 'ImageObject'
    | 'Include'
    | 'IntegerValidator'
    | 'Link'
    | 'List'
    | 'ListItem'
    | 'Mark'
    | 'Math'
    | 'MathBlock'
    | 'MathFragment'
    | 'MediaObject'
    | 'MonetaryGrant'
    | 'NontextualAnnotation'
    | 'Note'
    | 'NumberValidator'
    | 'Organization'
    | 'Paragraph'
    | 'Parameter'
    | 'Periodical'
    | 'Person'
    | 'PostalAddress'
    | 'Product'
    | 'PropertyValue'
    | 'PublicationIssue'
    | 'PublicationVolume'
    | 'Quote'
    | 'QuoteBlock'
    | 'Review'
    | 'SoftwareApplication'
    | 'SoftwareEnvironment'
    | 'SoftwareSession'
    | 'SoftwareSourceCode'
    | 'Strikeout'
    | 'StringValidator'
    | 'Strong'
    | 'Subscript'
    | 'Superscript'
    | 'Table'
    | 'TableCell'
    | 'TableRow'
    | 'ThematicBreak'
    | 'Thing'
    | 'TupleValidator'
    | 'Underline'
    | 'Validator'
    | 'Variable'
    | 'VideoObject'
    | 'VolumeMount'
  id?: string
  meta?: { [property: string]: Primitive }
}

/**
 * Create a `Entity` node
 * @param props Object containing Entity schema properties as key/value pairs
 * @returns {Entity} Entity schema node
 */
export const entity = (props: Omit<Entity, 'type'> = {}): Entity => ({
  ...compact(props),
  type: 'Entity',
})

/**
 * A reference to a CreativeWork that is cited in another CreativeWork.
 */
export type Cite = Entity & {
  type: 'Cite'
  target: string
  citationIntent?: Array<CitationIntentEnumeration>
  citationMode?:
    | 'Parenthetical'
    | 'Narrative'
    | 'NarrativeAuthor'
    | 'NarrativeYear'
    | 'normal'
    | 'suppressAuthor'
  citationPrefix?: string
  citationSuffix?: string
  content?: Array<InlineContent>
  pageEnd?: Integer | string
  pageStart?: Integer | string
  pagination?: string
}

/**
 * Create a `Cite` node
 * @param props Object containing Cite schema properties as key/value pairs
 * @returns {Cite} Cite schema node
 */
export const cite = (props: Omit<Cite, 'type'>): Cite => ({
  ...compact(props),
  type: 'Cite',
})

/**
 * A group of Cite nodes.
 */
export type CiteGroup = Entity & {
  type: 'CiteGroup'
  items: Array<Cite>
}

/**
 * Create a `CiteGroup` node
 * @param props Object containing CiteGroup schema properties as key/value pairs
 * @returns {CiteGroup} CiteGroup schema node
 */
export const citeGroup = (props: Omit<CiteGroup, 'type'>): CiteGroup => ({
  ...compact(props),
  type: 'CiteGroup',
})

/**
 * Base type for non-executable (e.g. `CodeBlock`) and executable (e.g. `CodeExpression`) code nodes.
 */
export type Code = Entity & {
  type:
    | 'Code'
    | 'CodeBlock'
    | 'CodeChunk'
    | 'CodeExecutable'
    | 'CodeExpression'
    | 'CodeFragment'
  text: string
  mediaType?: string
  programmingLanguage?: string
}

/**
 * Create a `Code` node
 * @param props Object containing Code schema properties as key/value pairs
 * @returns {Code} Code schema node
 */
export const code = (props: Omit<Code, 'type'>): Code => ({
  ...compact(props),
  type: 'Code',
})

/**
 * A code block.
 */
export type CodeBlock = Code & {
  type: 'CodeBlock'
}

/**
 * Create a `CodeBlock` node
 * @param props Object containing CodeBlock schema properties as key/value pairs
 * @returns {CodeBlock} CodeBlock schema node
 */
export const codeBlock = (props: Omit<CodeBlock, 'type'>): CodeBlock => ({
  ...compact(props),
  type: 'CodeBlock',
})

/**
 * Base type for executable code nodes (i.e. `CodeChunk` and `CodeExpression`).
 */
export type CodeExecutable = Code & {
  type: 'CodeExecutable' | 'CodeChunk' | 'CodeExpression'
  programmingLanguage: string
  codeDependencies?: Array<CodeChunk | Parameter>
  codeDependents?: Array<CodeChunk | CodeExpression>
  compileDigest?: string
  errors?: Array<CodeError>
  executeCount?: Integer
  executeDigest?: string
  executeDuration?: number
  executeEnded?: Date
  executeRequired?:
    | 'No'
    | 'NeverExecuted'
    | 'SemanticsChanged'
    | 'DependenciesChanged'
    | 'DependenciesFailed'
    | 'Failed'
  executeStatus?:
    | 'Scheduled'
    | 'ScheduledPreviouslyFailed'
    | 'Running'
    | 'RunningPreviouslyFailed'
    | 'Succeeded'
    | 'Failed'
    | 'Cancelled'
}

/**
 * Create a `CodeExecutable` node
 * @param props Object containing CodeExecutable schema properties as key/value pairs
 * @returns {CodeExecutable} CodeExecutable schema node
 */
export const codeExecutable = (
  props: Omit<CodeExecutable, 'type'>
): CodeExecutable => ({
  ...compact(props),
  type: 'CodeExecutable',
})

/**
 * A executable chunk of code.
 */
export type CodeChunk = CodeExecutable & {
  type: 'CodeChunk'
  programmingLanguage: string
  caption?: Array<BlockContent> | string
  executeAuto?: 'Never' | 'Needed' | 'Always'
  executePure?: boolean
  label?: string
  outputs?: Array<Node>
}

/**
 * Create a `CodeChunk` node
 * @param props Object containing CodeChunk schema properties as key/value pairs
 * @returns {CodeChunk} CodeChunk schema node
 */
export const codeChunk = (props: Omit<CodeChunk, 'type'>): CodeChunk => ({
  ...compact(props),
  type: 'CodeChunk',
})

/**
 * An executable programming code expression.
 */
export type CodeExpression = CodeExecutable & {
  type: 'CodeExpression'
  programmingLanguage: string
  output?: Node
}

/**
 * Create a `CodeExpression` node
 * @param props Object containing CodeExpression schema properties as key/value pairs
 * @returns {CodeExpression} CodeExpression schema node
 */
export const codeExpression = (
  props: Omit<CodeExpression, 'type'>
): CodeExpression => ({
  ...compact(props),
  type: 'CodeExpression',
})

/**
 * Inline code.
 */
export type CodeFragment = Code & {
  type: 'CodeFragment'
}

/**
 * Create a `CodeFragment` node
 * @param props Object containing CodeFragment schema properties as key/value pairs
 * @returns {CodeFragment} CodeFragment schema node
 */
export const codeFragment = (
  props: Omit<CodeFragment, 'type'>
): CodeFragment => ({
  ...compact(props),
  type: 'CodeFragment',
})

/**
 * An error that occurred when parsing, compiling or executing a Code node.
 */
export type CodeError = Entity & {
  type: 'CodeError'
  errorMessage: string
  errorType?: string
  stackTrace?: string
}

/**
 * Create a `CodeError` node
 * @param props Object containing CodeError schema properties as key/value pairs
 * @returns {CodeError} CodeError schema node
 */
export const codeError = (props: Omit<CodeError, 'type'>): CodeError => ({
  ...compact(props),
  type: 'CodeError',
})

/**
 * A date encoded as a ISO 8601 string.
 */
export type Date = Entity & {
  type: 'Date'
  value: string
}

/**
 * Create a `Date` node
 * @param props Object containing Date schema properties as key/value pairs
 * @returns {Date} Date schema node
 */
export const date = (props: Omit<Date, 'type'>): Date => ({
  ...compact(props),
  type: 'Date',
})

/**
 * A base class for nodes that mark some other inline content
 * in some way (e.g. as being emphasised, or quoted).
 */
export type Mark = Entity & {
  type:
    | 'Mark'
    | 'Delete'
    | 'Emphasis'
    | 'NontextualAnnotation'
    | 'Quote'
    | 'Strikeout'
    | 'Strong'
    | 'Subscript'
    | 'Superscript'
    | 'Underline'
  content: Array<InlineContent>
}

/**
 * Create a `Mark` node
 * @param props Object containing Mark schema properties as key/value pairs
 * @returns {Mark} Mark schema node
 */
export const mark = (props: Omit<Mark, 'type'>): Mark => ({
  ...compact(props),
  type: 'Mark',
})

/**
 * Content that is marked for deletion
 */
export type Delete = Mark & {
  type: 'Delete'
}

/**
 * Create a `Delete` node
 * @param props Object containing Delete schema properties as key/value pairs
 * @returns {Delete} Delete schema node
 */
export const del = (props: Omit<Delete, 'type'>): Delete => ({
  ...compact(props),
  type: 'Delete',
})

/**
 * Emphasised content.
 */
export type Emphasis = Mark & {
  type: 'Emphasis'
}

/**
 * Create a `Emphasis` node
 * @param props Object containing Emphasis schema properties as key/value pairs
 * @returns {Emphasis} Emphasis schema node
 */
export const emphasis = (props: Omit<Emphasis, 'type'>): Emphasis => ({
  ...compact(props),
  type: 'Emphasis',
})

/**
 * The most generic type of item.
 */
export type Thing = Entity & {
  type:
    | 'Thing'
    | 'Article'
    | 'AudioObject'
    | 'Brand'
    | 'CitationIntentEnumeration'
    | 'Claim'
    | 'Collection'
    | 'Comment'
    | 'ContactPoint'
    | 'CreativeWork'
    | 'Datatable'
    | 'DatatableColumn'
    | 'DefinedTerm'
    | 'Enumeration'
    | 'Figure'
    | 'Grant'
    | 'ImageObject'
    | 'ListItem'
    | 'MediaObject'
    | 'MonetaryGrant'
    | 'Organization'
    | 'Periodical'
    | 'Person'
    | 'PostalAddress'
    | 'Product'
    | 'PropertyValue'
    | 'PublicationIssue'
    | 'PublicationVolume'
    | 'Review'
    | 'SoftwareApplication'
    | 'SoftwareEnvironment'
    | 'SoftwareSession'
    | 'SoftwareSourceCode'
    | 'Table'
    | 'VideoObject'
    | 'VolumeMount'
  alternateNames?: Array<string>
  description?: Array<BlockContent> | Array<InlineContent> | string
  identifiers?: Array<PropertyValue | string>
  images?: Array<ImageObject | string>
  name?: string
  url?: string
}

/**
 * Create a `Thing` node
 * @param props Object containing Thing schema properties as key/value pairs
 * @returns {Thing} Thing schema node
 */
export const thing = (props: Omit<Thing, 'type'> = {}): Thing => ({
  ...compact(props),
  type: 'Thing',
})

/**
 * A brand used by an organization or person for labeling a product,
 * product group, or similar.
 */
export type Brand = Thing & {
  type: 'Brand'
  name: string
  logo?: ImageObject | string
  reviews?: Array<string>
}

/**
 * Create a `Brand` node
 * @param props Object containing Brand schema properties as key/value pairs
 * @returns {Brand} Brand schema node
 */
export const brand = (props: Omit<Brand, 'type'>): Brand => ({
  ...compact(props),
  type: 'Brand',
})

/**
 * A contact point, usually within an organization.
 */
export type ContactPoint = Thing & {
  type: 'ContactPoint' | 'PostalAddress'
  availableLanguages?: Array<string>
  emails?: Array<string>
  telephoneNumbers?: Array<string>
}

/**
 * Create a `ContactPoint` node
 * @param props Object containing ContactPoint schema properties as key/value pairs
 * @returns {ContactPoint} ContactPoint schema node
 */
export const contactPoint = (
  props: Omit<ContactPoint, 'type'> = {}
): ContactPoint => ({
  ...compact(props),
  type: 'ContactPoint',
})

/**
 * A creative work, including books, movies, photographs, software programs, etc.
 */
export type CreativeWork = Thing & {
  type:
    | 'CreativeWork'
    | 'Article'
    | 'AudioObject'
    | 'Claim'
    | 'Collection'
    | 'Comment'
    | 'Datatable'
    | 'Figure'
    | 'ImageObject'
    | 'MediaObject'
    | 'Periodical'
    | 'PublicationIssue'
    | 'PublicationVolume'
    | 'Review'
    | 'SoftwareApplication'
    | 'SoftwareSourceCode'
    | 'Table'
    | 'VideoObject'
  about?: Array<ThingTypes>
  authors?: Array<Person | Organization>
  comments?: Array<Comment>
  content?: Array<Node> | string
  dateAccepted?: Date
  dateCreated?: Date
  dateModified?: Date
  datePublished?: Date
  dateReceived?: Date
  editors?: Array<Person>
  fundedBy?: Array<Grant | MonetaryGrant>
  funders?: Array<Person | Organization>
  genre?: Array<string>
  isPartOf?: CreativeWorkTypes
  keywords?: Array<string>
  licenses?: Array<CreativeWorkTypes | string>
  maintainers?: Array<Person | Organization>
  parts?: Array<CreativeWorkTypes>
  publisher?: Person | Organization
  references?: Array<CreativeWorkTypes | string>
  text?: string
  title?: Array<InlineContent> | string
  version?: string | number
}

/**
 * Create a `CreativeWork` node
 * @param props Object containing CreativeWork schema properties as key/value pairs
 * @returns {CreativeWork} CreativeWork schema node
 */
export const creativeWork = (
  props: Omit<CreativeWork, 'type'> = {}
): CreativeWork => ({
  ...compact(props),
  type: 'CreativeWork',
})

/**
 * An article, including news and scholarly articles.
 */
export type Article = CreativeWork & {
  type: 'Article'
  content?: Array<BlockContent>
  pageEnd?: Integer | string
  pageStart?: Integer | string
  pagination?: string
}

/**
 * Create a `Article` node
 * @param props Object containing Article schema properties as key/value pairs
 * @returns {Article} Article schema node
 */
export const article = (props: Omit<Article, 'type'> = {}): Article => ({
  ...compact(props),
  type: 'Article',
})

/**
 * A claim represents specific reviewable facts or statements.
 */
export type Claim = CreativeWork & {
  type: 'Claim'
  content: Array<BlockContent>
  claimType?:
    | 'Statement'
    | 'Theorem'
    | 'Lemma'
    | 'Proof'
    | 'Postulate'
    | 'Hypothesis'
    | 'Proposition'
    | 'Corollary'
  label?: string
}

/**
 * Create a `Claim` node
 * @param props Object containing Claim schema properties as key/value pairs
 * @returns {Claim} Claim schema node
 */
export const claim = (props: Omit<Claim, 'type'>): Claim => ({
  ...compact(props),
  type: 'Claim',
})

/**
 * A collection of CreativeWorks or other artifacts.
 */
export type Collection = CreativeWork & {
  type: 'Collection'
  parts: Array<CreativeWorkTypes>
}

/**
 * Create a `Collection` node
 * @param props Object containing Collection schema properties as key/value pairs
 * @returns {Collection} Collection schema node
 */
export const collection = (props: Omit<Collection, 'type'>): Collection => ({
  ...compact(props),
  type: 'Collection',
})

/**
 * A comment on an item, e.g on a Article, or SoftwareSourceCode.
 */
export type Comment = CreativeWork & {
  type: 'Comment'
  commentAspect?: string
  parentItem?: Comment
}

/**
 * Create a `Comment` node
 * @param props Object containing Comment schema properties as key/value pairs
 * @returns {Comment} Comment schema node
 */
export const comment = (props: Omit<Comment, 'type'> = {}): Comment => ({
  ...compact(props),
  type: 'Comment',
})

/**
 * A table of data.
 */
export type Datatable = CreativeWork & {
  type: 'Datatable'
  columns: Array<DatatableColumn>
}

/**
 * Create a `Datatable` node
 * @param props Object containing Datatable schema properties as key/value pairs
 * @returns {Datatable} Datatable schema node
 */
export const datatable = (props: Omit<Datatable, 'type'>): Datatable => ({
  ...compact(props),
  type: 'Datatable',
})

/**
 * A media object, such as an image, video, or audio object embedded in a web page or a
 * downloadable dataset.
 */
export type MediaObject = CreativeWork & {
  type: 'MediaObject' | 'AudioObject' | 'ImageObject' | 'VideoObject'
  contentUrl: string
  bitrate?: number
  contentSize?: number
  embedUrl?: string
  mediaType?: string
}

/**
 * Create a `MediaObject` node
 * @param props Object containing MediaObject schema properties as key/value pairs
 * @returns {MediaObject} MediaObject schema node
 */
export const mediaObject = (props: Omit<MediaObject, 'type'>): MediaObject => ({
  ...compact(props),
  type: 'MediaObject',
})

/**
 * An audio file
 */
export type AudioObject = MediaObject & {
  type: 'AudioObject'
  caption?: string
  transcript?: string
}

/**
 * Create a `AudioObject` node
 * @param props Object containing AudioObject schema properties as key/value pairs
 * @returns {AudioObject} AudioObject schema node
 */
export const audioObject = (props: Omit<AudioObject, 'type'>): AudioObject => ({
  ...compact(props),
  type: 'AudioObject',
})

/**
 * A column of data within a Datatable.
 */
export type DatatableColumn = Thing & {
  type: 'DatatableColumn'
  name: string
  values: Array<Node>
  validator?: ArrayValidator
}

/**
 * Create a `DatatableColumn` node
 * @param props Object containing DatatableColumn schema properties as key/value pairs
 * @returns {DatatableColumn} DatatableColumn schema node
 */
export const datatableColumn = (
  props: Omit<DatatableColumn, 'type'>
): DatatableColumn => ({
  ...compact(props),
  type: 'DatatableColumn',
})

/**
 * A word, name, acronym, phrase, etc. with a formal definition.
 */
export type DefinedTerm = Thing & {
  type: 'DefinedTerm'
  name: string
  termCode?: string
}

/**
 * Create a `DefinedTerm` node
 * @param props Object containing DefinedTerm schema properties as key/value pairs
 * @returns {DefinedTerm} DefinedTerm schema node
 */
export const definedTerm = (props: Omit<DefinedTerm, 'type'>): DefinedTerm => ({
  ...compact(props),
  type: 'DefinedTerm',
})

/**
 * A base for all validator types.
 */
export type Validator = Entity & {
  type:
    | 'Validator'
    | 'ArrayValidator'
    | 'BooleanValidator'
    | 'ConstantValidator'
    | 'EnumValidator'
    | 'IntegerValidator'
    | 'NumberValidator'
    | 'StringValidator'
    | 'TupleValidator'
}

/**
 * Create a `Validator` node
 * @param props Object containing Validator schema properties as key/value pairs
 * @returns {Validator} Validator schema node
 */
export const validator = (props: Omit<Validator, 'type'> = {}): Validator => ({
  ...compact(props),
  type: 'Validator',
})

/**
 * A validator specifying constraints on an array node.
 */
export type ArrayValidator = Validator & {
  type: 'ArrayValidator'
  contains?: ValidatorTypes
  itemsValidator?: ValidatorTypes
  maxItems?: Integer
  minItems?: Integer
  uniqueItems?: boolean
}

/**
 * Create a `ArrayValidator` node
 * @param props Object containing ArrayValidator schema properties as key/value pairs
 * @returns {ArrayValidator} ArrayValidator schema node
 */
export const arrayValidator = (
  props: Omit<ArrayValidator, 'type'> = {}
): ArrayValidator => ({
  ...compact(props),
  type: 'ArrayValidator',
})

/**
 * A schema specifying that a node must be a boolean value.
 */
export type BooleanValidator = Validator & {
  type: 'BooleanValidator'
}

/**
 * Create a `BooleanValidator` node
 * @param props Object containing BooleanValidator schema properties as key/value pairs
 * @returns {BooleanValidator} BooleanValidator schema node
 */
export const booleanValidator = (
  props: Omit<BooleanValidator, 'type'> = {}
): BooleanValidator => ({
  ...compact(props),
  type: 'BooleanValidator',
})

/**
 * A validator specifying a constant value that a node must have.
 */
export type ConstantValidator = Validator & {
  type: 'ConstantValidator'
  value: Node
}

/**
 * Create a `ConstantValidator` node
 * @param props Object containing ConstantValidator schema properties as key/value pairs
 * @returns {ConstantValidator} ConstantValidator schema node
 */
export const constantValidator = (
  props: Omit<ConstantValidator, 'type'>
): ConstantValidator => ({
  ...compact(props),
  type: 'ConstantValidator',
})

/**
 * A schema specifying that a node must be one of several values.
 */
export type EnumValidator = Validator & {
  type: 'EnumValidator'
  values: Array<Node>
}

/**
 * Create a `EnumValidator` node
 * @param props Object containing EnumValidator schema properties as key/value pairs
 * @returns {EnumValidator} EnumValidator schema node
 */
export const enumValidator = (
  props: Omit<EnumValidator, 'type'>
): EnumValidator => ({
  ...compact(props),
  type: 'EnumValidator',
})

/**
 * Lists or enumerations, for example, a list of cuisines or music genres, etc.
 */
export type Enumeration = Thing & {
  type: 'Enumeration' | 'CitationIntentEnumeration'
}

/**
 * Create a `Enumeration` node
 * @param props Object containing Enumeration schema properties as key/value pairs
 * @returns {Enumeration} Enumeration schema node
 */
export const enumeration = (
  props: Omit<Enumeration, 'type'> = {}
): Enumeration => ({
  ...compact(props),
  type: 'Enumeration',
})

/**
 * Encapsulates one or more images, videos, tables, etc, and provides captions and labels for them.
 */
export type Figure = CreativeWork & {
  type: 'Figure'
  caption?: Array<BlockContent> | string
  label?: string
}

/**
 * Create a `Figure` node
 * @param props Object containing Figure schema properties as key/value pairs
 * @returns {Figure} Figure schema node
 */
export const figure = (props: Omit<Figure, 'type'> = {}): Figure => ({
  ...compact(props),
  type: 'Figure',
})

/**
 * A function with a name, which might take Parameters and return a value of a certain type.
 */
export type Function = Entity & {
  type: 'Function'
  name?: string
  parameters?: Array<Parameter>
  returns?: ValidatorTypes
}

/**
 * Create a `Function` node
 * @param props Object containing Function schema properties as key/value pairs
 * @returns {Function} Function schema node
 */
export const function_ = (props: Omit<Function, 'type'> = {}): Function => ({
  ...compact(props),
  type: 'Function',
})

/**
 * A grant, typically financial or otherwise quantifiable, of resources.
 */
export type Grant = Thing & {
  type: 'Grant' | 'MonetaryGrant'
  fundedItems?: Array<Thing>
  sponsors?: Array<Person | Organization>
}

/**
 * Create a `Grant` node
 * @param props Object containing Grant schema properties as key/value pairs
 * @returns {Grant} Grant schema node
 */
export const grant = (props: Omit<Grant, 'type'> = {}): Grant => ({
  ...compact(props),
  type: 'Grant',
})

/**
 * A heading.
 */
export type Heading = Entity & {
  type: 'Heading'
  content: Array<InlineContent>
  depth?: Integer
}

/**
 * Create a `Heading` node
 * @param props Object containing Heading schema properties as key/value pairs
 * @returns {Heading} Heading schema node
 */
export const heading = (props: Omit<Heading, 'type'>): Heading => ({
  ...compact(props),
  type: 'Heading',
})

/**
 * An image file.
 */
export type ImageObject = MediaObject & {
  type: 'ImageObject'
  caption?: string
  thumbnail?: ImageObject
}

/**
 * Create a `ImageObject` node
 * @param props Object containing ImageObject schema properties as key/value pairs
 * @returns {ImageObject} ImageObject schema node
 */
export const imageObject = (props: Omit<ImageObject, 'type'>): ImageObject => ({
  ...compact(props),
  type: 'ImageObject',
})

/**
 * Include content from an external source (e.g. file, URL).
 */
export type Include = Entity & {
  type: 'Include'
  source: string
  buildDigest?: string
  content?: Array<BlockContent>
  mediaType?: string
}

/**
 * Create a `Include` node
 * @param props Object containing Include schema properties as key/value pairs
 * @returns {Include} Include schema node
 */
export const include = (props: Omit<Include, 'type'>): Include => ({
  ...compact(props),
  type: 'Include',
})

/**
 * A validator specifying the constraints on a numeric node.
 */
export type NumberValidator = Validator & {
  type: 'NumberValidator' | 'IntegerValidator'
  exclusiveMaximum?: number
  exclusiveMinimum?: number
  maximum?: number
  minimum?: number
  multipleOf?: number
}

/**
 * Create a `NumberValidator` node
 * @param props Object containing NumberValidator schema properties as key/value pairs
 * @returns {NumberValidator} NumberValidator schema node
 */
export const numberValidator = (
  props: Omit<NumberValidator, 'type'> = {}
): NumberValidator => ({
  ...compact(props),
  type: 'NumberValidator',
})

/**
 * A validator specifying the constraints on an integer node.
 */
export type IntegerValidator = NumberValidator & {
  type: 'IntegerValidator'
}

/**
 * Create a `IntegerValidator` node
 * @param props Object containing IntegerValidator schema properties as key/value pairs
 * @returns {IntegerValidator} IntegerValidator schema node
 */
export const integerValidator = (
  props: Omit<IntegerValidator, 'type'> = {}
): IntegerValidator => ({
  ...compact(props),
  type: 'IntegerValidator',
})

/**
 * A hyperlink to other pages, sections within the same document, resources, or any URL.
 */
export type Link = Entity & {
  type: 'Link'
  content: Array<InlineContent>
  target: string
  exportFrom?: string
  importTo?: string
  relation?: string
  title?: string
}

/**
 * Create a `Link` node
 * @param props Object containing Link schema properties as key/value pairs
 * @returns {Link} Link schema node
 */
export const link = (props: Omit<Link, 'type'>): Link => ({
  ...compact(props),
  type: 'Link',
})

/**
 * A list of items.
 */
export type List = Entity & {
  type: 'List'
  items: Array<ListItem>
  order?: 'Ascending' | 'Descending' | 'Unordered'
}

/**
 * Create a `List` node
 * @param props Object containing List schema properties as key/value pairs
 * @returns {List} List schema node
 */
export const list = (props: Omit<List, 'type'>): List => ({
  ...compact(props),
  type: 'List',
})

/**
 * A single item in a list.
 */
export type ListItem = Thing & {
  type: 'ListItem'
  content?: Array<BlockContent> | Array<InlineContent>
  isChecked?: boolean
  item?: Node
  position?: Integer
}

/**
 * Create a `ListItem` node
 * @param props Object containing ListItem schema properties as key/value pairs
 * @returns {ListItem} ListItem schema node
 */
export const listItem = (props: Omit<ListItem, 'type'> = {}): ListItem => ({
  ...compact(props),
  type: 'ListItem',
})

/**
 * A mathematical variable or equation.
 */
export type Math = Entity & {
  type: 'Math' | 'MathBlock' | 'MathFragment'
  text: string
  errors?: Array<string>
  mathLanguage?: string
}

/**
 * Create a `Math` node
 * @param props Object containing Math schema properties as key/value pairs
 * @returns {Math} Math schema node
 */
export const math = (props: Omit<Math, 'type'>): Math => ({
  ...compact(props),
  type: 'Math',
})

/**
 * A block of math, e.g an equation, to be treated as block content.
 */
export type MathBlock = Math & {
  type: 'MathBlock'
  label?: string
}

/**
 * Create a `MathBlock` node
 * @param props Object containing MathBlock schema properties as key/value pairs
 * @returns {MathBlock} MathBlock schema node
 */
export const mathBlock = (props: Omit<MathBlock, 'type'>): MathBlock => ({
  ...compact(props),
  type: 'MathBlock',
})

/**
 * A fragment of math, e.g a variable name, to be treated as inline content.
 */
export type MathFragment = Math & {
  type: 'MathFragment'
}

/**
 * Create a `MathFragment` node
 * @param props Object containing MathFragment schema properties as key/value pairs
 * @returns {MathFragment} MathFragment schema node
 */
export const mathFragment = (
  props: Omit<MathFragment, 'type'>
): MathFragment => ({
  ...compact(props),
  type: 'MathFragment',
})

/**
 * A monetary grant.
 */
export type MonetaryGrant = Grant & {
  type: 'MonetaryGrant'
  amounts?: number
  funders?: Array<Person | Organization>
}

/**
 * Create a `MonetaryGrant` node
 * @param props Object containing MonetaryGrant schema properties as key/value pairs
 * @returns {MonetaryGrant} MonetaryGrant schema node
 */
export const monetaryGrant = (
  props: Omit<MonetaryGrant, 'type'> = {}
): MonetaryGrant => ({
  ...compact(props),
  type: 'MonetaryGrant',
})

/**
 * Inline text that has a non-textual annotation.
 */
export type NontextualAnnotation = Mark & {
  type: 'NontextualAnnotation'
}

/**
 * Create a `NontextualAnnotation` node
 * @param props Object containing NontextualAnnotation schema properties as key/value pairs
 * @returns {NontextualAnnotation} NontextualAnnotation schema node
 */
export const nontextualAnnotation = (
  props: Omit<NontextualAnnotation, 'type'>
): NontextualAnnotation => ({
  ...compact(props),
  type: 'NontextualAnnotation',
})

/**
 * Additional content which is not part of the main content of a document.
 */
export type Note = Entity & {
  type: 'Note'
  content: Array<BlockContent>
  noteType?: 'Footnote' | 'Endnote' | 'Sidenote'
}

/**
 * Create a `Note` node
 * @param props Object containing Note schema properties as key/value pairs
 * @returns {Note} Note schema node
 */
export const note = (props: Omit<Note, 'type'>): Note => ({
  ...compact(props),
  type: 'Note',
})

/**
 * An organization such as a school, NGO, corporation, club, etc.
 */
export type Organization = Thing & {
  type: 'Organization'
  address?: PostalAddress | string
  brands?: Array<Brand>
  contactPoints?: Array<ContactPoint>
  departments?: Array<Organization>
  funders?: Array<Organization | Person>
  legalName?: string
  logo?: ImageObject | string
  members?: Array<Organization | Person>
  parentOrganization?: Organization
}

/**
 * Create a `Organization` node
 * @param props Object containing Organization schema properties as key/value pairs
 * @returns {Organization} Organization schema node
 */
export const organization = (
  props: Omit<Organization, 'type'> = {}
): Organization => ({
  ...compact(props),
  type: 'Organization',
})

/**
 * Paragraph
 */
export type Paragraph = Entity & {
  type: 'Paragraph'
  content: Array<InlineContent>
}

/**
 * Create a `Paragraph` node
 * @param props Object containing Paragraph schema properties as key/value pairs
 * @returns {Paragraph} Paragraph schema node
 */
export const paragraph = (props: Omit<Paragraph, 'type'>): Paragraph => ({
  ...compact(props),
  type: 'Paragraph',
})

/**
 * A parameter of a document or function.
 */
export type Parameter = Entity & {
  type: 'Parameter'
  name: string
  default?: Node
  executeDigest?: string
  isExtensible?: boolean
  isRequired?: boolean
  isVariadic?: boolean
  validator?: ValidatorTypes
  value?: Node
}

/**
 * Create a `Parameter` node
 * @param props Object containing Parameter schema properties as key/value pairs
 * @returns {Parameter} Parameter schema node
 */
export const parameter = (props: Omit<Parameter, 'type'>): Parameter => ({
  ...compact(props),
  type: 'Parameter',
})

/**
 * A periodical publication.
 */
export type Periodical = CreativeWork & {
  type: 'Periodical'
  dateEnd?: Date
  dateStart?: Date
  issns?: Array<string>
}

/**
 * Create a `Periodical` node
 * @param props Object containing Periodical schema properties as key/value pairs
 * @returns {Periodical} Periodical schema node
 */
export const periodical = (
  props: Omit<Periodical, 'type'> = {}
): Periodical => ({
  ...compact(props),
  type: 'Periodical',
})

/**
 * A person (alive, dead, undead, or fictional).
 */
export type Person = Thing & {
  type: 'Person'
  address?: PostalAddress | string
  affiliations?: Array<Organization>
  emails?: Array<string>
  familyNames?: Array<string>
  funders?: Array<Organization | Person>
  givenNames?: Array<string>
  honorificPrefix?: string
  honorificSuffix?: string
  jobTitle?: string
  memberOf?: Array<Organization>
  telephoneNumbers?: Array<string>
}

/**
 * Create a `Person` node
 * @param props Object containing Person schema properties as key/value pairs
 * @returns {Person} Person schema node
 */
export const person = (props: Omit<Person, 'type'> = {}): Person => ({
  ...compact(props),
  type: 'Person',
})

/**
 * A physical mailing address.
 */
export type PostalAddress = ContactPoint & {
  type: 'PostalAddress'
  addressCountry?: string
  addressLocality?: string
  addressRegion?: string
  postOfficeBoxNumber?: string
  postalCode?: string
  streetAddress?: string
}

/**
 * Create a `PostalAddress` node
 * @param props Object containing PostalAddress schema properties as key/value pairs
 * @returns {PostalAddress} PostalAddress schema node
 */
export const postalAddress = (
  props: Omit<PostalAddress, 'type'> = {}
): PostalAddress => ({
  ...compact(props),
  type: 'PostalAddress',
})

/**
 * Any offered product or service. For example, a pair of shoes;
 * a haircut; or an episode of a TV show streamed online.
 */
export type Product = Thing & {
  type: 'Product'
  brands?: Array<Brand>
  logo?: ImageObject | string
  productID?: string
}

/**
 * Create a `Product` node
 * @param props Object containing Product schema properties as key/value pairs
 * @returns {Product} Product schema node
 */
export const product = (props: Omit<Product, 'type'> = {}): Product => ({
  ...compact(props),
  type: 'Product',
})

/**
 * A property-value pair.
 */
export type PropertyValue = Thing & {
  type: 'PropertyValue'
  value: boolean | Integer | number | string
  propertyID?: string
}

/**
 * Create a `PropertyValue` node
 * @param props Object containing PropertyValue schema properties as key/value pairs
 * @returns {PropertyValue} PropertyValue schema node
 */
export const propertyValue = (
  props: Omit<PropertyValue, 'type'>
): PropertyValue => ({
  ...compact(props),
  type: 'PropertyValue',
})

/**
 * A part of a successively published publication such as a periodical or publication
 * volume, often numbered.
 */
export type PublicationIssue = CreativeWork & {
  type: 'PublicationIssue'
  issueNumber?: Integer | string
  pageEnd?: Integer | string
  pageStart?: Integer | string
  pagination?: string
}

/**
 * Create a `PublicationIssue` node
 * @param props Object containing PublicationIssue schema properties as key/value pairs
 * @returns {PublicationIssue} PublicationIssue schema node
 */
export const publicationIssue = (
  props: Omit<PublicationIssue, 'type'> = {}
): PublicationIssue => ({
  ...compact(props),
  type: 'PublicationIssue',
})

/**
 * A part of a successively published publication such as a periodical or multi-volume work.
 */
export type PublicationVolume = CreativeWork & {
  type: 'PublicationVolume'
  pageEnd?: Integer | string
  pageStart?: Integer | string
  pagination?: string
  volumeNumber?: Integer | string
}

/**
 * Create a `PublicationVolume` node
 * @param props Object containing PublicationVolume schema properties as key/value pairs
 * @returns {PublicationVolume} PublicationVolume schema node
 */
export const publicationVolume = (
  props: Omit<PublicationVolume, 'type'> = {}
): PublicationVolume => ({
  ...compact(props),
  type: 'PublicationVolume',
})

/**
 * Inline, quoted content.
 */
export type Quote = Mark & {
  type: 'Quote'
  cite?: Cite | string
}

/**
 * Create a `Quote` node
 * @param props Object containing Quote schema properties as key/value pairs
 * @returns {Quote} Quote schema node
 */
export const quote = (props: Omit<Quote, 'type'>): Quote => ({
  ...compact(props),
  type: 'Quote',
})

/**
 * A section quoted from somewhere else.
 */
export type QuoteBlock = Entity & {
  type: 'QuoteBlock'
  content: Array<BlockContent>
  cite?: Cite | string
}

/**
 * Create a `QuoteBlock` node
 * @param props Object containing QuoteBlock schema properties as key/value pairs
 * @returns {QuoteBlock} QuoteBlock schema node
 */
export const quoteBlock = (props: Omit<QuoteBlock, 'type'>): QuoteBlock => ({
  ...compact(props),
  type: 'QuoteBlock',
})

/**
 * A review of an item, e.g of an Article, or SoftwareSourceCode.
 */
export type Review = CreativeWork & {
  type: 'Review'
  itemReviewed?: Thing
  reviewAspect?: string
}

/**
 * Create a `Review` node
 * @param props Object containing Review schema properties as key/value pairs
 * @returns {Review} Review schema node
 */
export const review = (props: Omit<Review, 'type'> = {}): Review => ({
  ...compact(props),
  type: 'Review',
})

/**
 * A software application.
 */
export type SoftwareApplication = CreativeWork & {
  type: 'SoftwareApplication'
  softwareRequirements?: Array<SoftwareApplication>
  softwareVersion?: string
}

/**
 * Create a `SoftwareApplication` node
 * @param props Object containing SoftwareApplication schema properties as key/value pairs
 * @returns {SoftwareApplication} SoftwareApplication schema node
 */
export const softwareApplication = (
  props: Omit<SoftwareApplication, 'type'> = {}
): SoftwareApplication => ({
  ...compact(props),
  type: 'SoftwareApplication',
})

/**
 * A computational environment.
 */
export type SoftwareEnvironment = Thing & {
  type: 'SoftwareEnvironment'
  name: string
  adds?: Array<SoftwareSourceCode>
  extends?: Array<SoftwareEnvironment>
  removes?: Array<SoftwareSourceCode>
}

/**
 * Create a `SoftwareEnvironment` node
 * @param props Object containing SoftwareEnvironment schema properties as key/value pairs
 * @returns {SoftwareEnvironment} SoftwareEnvironment schema node
 */
export const softwareEnvironment = (
  props: Omit<SoftwareEnvironment, 'type'>
): SoftwareEnvironment => ({
  ...compact(props),
  type: 'SoftwareEnvironment',
})

/**
 * Definition of a compute session, including its software and compute resource
 * requirements and status.
 */
export type SoftwareSession = Thing & {
  type: 'SoftwareSession'
  clientsLimit?: number
  clientsRequest?: number
  cpuLimit?: number
  cpuRequest?: number
  dateEnd?: Date
  dateStart?: Date
  durationLimit?: number
  durationRequest?: number
  environment?: SoftwareEnvironment
  memoryLimit?: number
  memoryRequest?: number
  networkTransferLimit?: number
  networkTransferRequest?: number
  status?:
    | 'Unknown'
    | 'Starting'
    | 'Started'
    | 'Stopping'
    | 'Stopped'
    | 'Failed'
  timeoutLimit?: number
  timeoutRequest?: number
  volumeMounts?: Array<VolumeMount>
}

/**
 * Create a `SoftwareSession` node
 * @param props Object containing SoftwareSession schema properties as key/value pairs
 * @returns {SoftwareSession} SoftwareSession schema node
 */
export const softwareSession = (
  props: Omit<SoftwareSession, 'type'> = {}
): SoftwareSession => ({
  ...compact(props),
  type: 'SoftwareSession',
})

/**
 * Computer programming source code. Example: Full (compile ready) solutions, code snippet samples, scripts, templates.
 */
export type SoftwareSourceCode = CreativeWork & {
  type: 'SoftwareSourceCode'
  codeRepository?: string
  codeSampleType?: string
  programmingLanguage?: string
  runtimePlatform?: Array<string>
  softwareRequirements?: Array<
    SoftwareSourceCode | SoftwareApplication | string
  >
  targetProducts?: Array<SoftwareApplication>
}

/**
 * Create a `SoftwareSourceCode` node
 * @param props Object containing SoftwareSourceCode schema properties as key/value pairs
 * @returns {SoftwareSourceCode} SoftwareSourceCode schema node
 */
export const softwareSourceCode = (
  props: Omit<SoftwareSourceCode, 'type'> = {}
): SoftwareSourceCode => ({
  ...compact(props),
  type: 'SoftwareSourceCode',
})

/**
 * Content that is marked as struck out
 */
export type Strikeout = Mark & {
  type: 'Strikeout'
}

/**
 * Create a `Strikeout` node
 * @param props Object containing Strikeout schema properties as key/value pairs
 * @returns {Strikeout} Strikeout schema node
 */
export const strikeout = (props: Omit<Strikeout, 'type'>): Strikeout => ({
  ...compact(props),
  type: 'Strikeout',
})

/**
 * A schema specifying constraints on a string node.
 */
export type StringValidator = Validator & {
  type: 'StringValidator'
  maxLength?: Integer
  minLength?: Integer
  pattern?: string
}

/**
 * Create a `StringValidator` node
 * @param props Object containing StringValidator schema properties as key/value pairs
 * @returns {StringValidator} StringValidator schema node
 */
export const stringValidator = (
  props: Omit<StringValidator, 'type'> = {}
): StringValidator => ({
  ...compact(props),
  type: 'StringValidator',
})

/**
 * Strongly emphasised content.
 */
export type Strong = Mark & {
  type: 'Strong'
}

/**
 * Create a `Strong` node
 * @param props Object containing Strong schema properties as key/value pairs
 * @returns {Strong} Strong schema node
 */
export const strong = (props: Omit<Strong, 'type'>): Strong => ({
  ...compact(props),
  type: 'Strong',
})

/**
 * Subscripted content.
 */
export type Subscript = Mark & {
  type: 'Subscript'
}

/**
 * Create a `Subscript` node
 * @param props Object containing Subscript schema properties as key/value pairs
 * @returns {Subscript} Subscript schema node
 */
export const subscript = (props: Omit<Subscript, 'type'>): Subscript => ({
  ...compact(props),
  type: 'Subscript',
})

/**
 * Superscripted content.
 */
export type Superscript = Mark & {
  type: 'Superscript'
}

/**
 * Create a `Superscript` node
 * @param props Object containing Superscript schema properties as key/value pairs
 * @returns {Superscript} Superscript schema node
 */
export const superscript = (props: Omit<Superscript, 'type'>): Superscript => ({
  ...compact(props),
  type: 'Superscript',
})

/**
 * A table.
 */
export type Table = CreativeWork & {
  type: 'Table'
  rows: Array<TableRow>
  caption?: Array<BlockContent> | string
  label?: string
}

/**
 * Create a `Table` node
 * @param props Object containing Table schema properties as key/value pairs
 * @returns {Table} Table schema node
 */
export const table = (props: Omit<Table, 'type'>): Table => ({
  ...compact(props),
  type: 'Table',
})

/**
 * A cell within a `Table`.
 */
export type TableCell = Entity & {
  type: 'TableCell'
  cellType?: 'Data' | 'Header'
  colspan?: Integer
  content?: Array<BlockContent> | Array<InlineContent>
  name?: string
  rowspan?: Integer
}

/**
 * Create a `TableCell` node
 * @param props Object containing TableCell schema properties as key/value pairs
 * @returns {TableCell} TableCell schema node
 */
export const tableCell = (props: Omit<TableCell, 'type'> = {}): TableCell => ({
  ...compact(props),
  type: 'TableCell',
})

/**
 * A row within a Table.
 */
export type TableRow = Entity & {
  type: 'TableRow'
  cells: Array<TableCell>
  rowType?: 'Header' | 'Footer'
}

/**
 * Create a `TableRow` node
 * @param props Object containing TableRow schema properties as key/value pairs
 * @returns {TableRow} TableRow schema node
 */
export const tableRow = (props: Omit<TableRow, 'type'>): TableRow => ({
  ...compact(props),
  type: 'TableRow',
})

/**
 * A thematic break, such as a scene change in a story, a transition to another topic, or a new document.
 */
export type ThematicBreak = Entity & {
  type: 'ThematicBreak'
}

/**
 * Create a `ThematicBreak` node
 * @param props Object containing ThematicBreak schema properties as key/value pairs
 * @returns {ThematicBreak} ThematicBreak schema node
 */
export const thematicBreak = (
  props: Omit<ThematicBreak, 'type'> = {}
): ThematicBreak => ({
  ...compact(props),
  type: 'ThematicBreak',
})

/**
 * A validator specifying constraints on an array of heterogeneous items.
 */
export type TupleValidator = Validator & {
  type: 'TupleValidator'
  items?: Array<ValidatorTypes>
}

/**
 * Create a `TupleValidator` node
 * @param props Object containing TupleValidator schema properties as key/value pairs
 * @returns {TupleValidator} TupleValidator schema node
 */
export const tupleValidator = (
  props: Omit<TupleValidator, 'type'> = {}
): TupleValidator => ({
  ...compact(props),
  type: 'TupleValidator',
})

/**
 * Inline text that is underlined.
 */
export type Underline = Mark & {
  type: 'Underline'
}

/**
 * Create a `Underline` node
 * @param props Object containing Underline schema properties as key/value pairs
 * @returns {Underline} Underline schema node
 */
export const underline = (props: Omit<Underline, 'type'>): Underline => ({
  ...compact(props),
  type: 'Underline',
})

/**
 * A variable representing a name / value pair.
 */
export type Variable = Entity & {
  type: 'Variable'
  name: string
  isReadonly?: boolean
  validator?: ValidatorTypes
  value?: Node
}

/**
 * Create a `Variable` node
 * @param props Object containing Variable schema properties as key/value pairs
 * @returns {Variable} Variable schema node
 */
export const variable = (props: Omit<Variable, 'type'>): Variable => ({
  ...compact(props),
  type: 'Variable',
})

/**
 * A video file.
 */
export type VideoObject = MediaObject & {
  type: 'VideoObject'
  caption?: string
  thumbnail?: ImageObject
  transcript?: string
}

/**
 * Create a `VideoObject` node
 * @param props Object containing VideoObject schema properties as key/value pairs
 * @returns {VideoObject} VideoObject schema node
 */
export const videoObject = (props: Omit<VideoObject, 'type'>): VideoObject => ({
  ...compact(props),
  type: 'VideoObject',
})

/**
 * Describes a volume mount from a host to container.
 */
export type VolumeMount = Thing & {
  type: 'VolumeMount'
  mountDestination: string
  mountOptions?: Array<string>
  mountSource?: string
  mountType?: string
}

/**
 * Create a `VolumeMount` node
 * @param props Object containing VolumeMount schema properties as key/value pairs
 * @returns {VolumeMount} VolumeMount schema node
 */
export const volumeMount = (props: Omit<VolumeMount, 'type'>): VolumeMount => ({
  ...compact(props),
  type: 'VolumeMount',
})

/**
 * Union type for valid block content.
 */
export type BlockContent =
  | Claim
  | CodeBlock
  | CodeChunk
  | Collection
  | Figure
  | Heading
  | Include
  | List
  | MathBlock
  | Paragraph
  | QuoteBlock
  | Table
  | ThematicBreak

/**
 * All type schemas that are derived from CodeExecutable
 */
export type CodeExecutableTypes = CodeExecutable | CodeChunk | CodeExpression

/**
 * All type schemas that are derived from Code
 */
export type CodeTypes =
  | Code
  | CodeBlock
  | CodeChunk
  | CodeExecutable
  | CodeExpression
  | CodeFragment

/**
 * All type schemas that are derived from ContactPoint
 */
export type ContactPointTypes = ContactPoint | PostalAddress

/**
 * All type schemas that are derived from CreativeWork
 */
export type CreativeWorkTypes =
  | CreativeWork
  | Article
  | AudioObject
  | Claim
  | Collection
  | Comment
  | Datatable
  | Figure
  | ImageObject
  | MediaObject
  | Periodical
  | PublicationIssue
  | PublicationVolume
  | Review
  | SoftwareApplication
  | SoftwareSourceCode
  | Table
  | VideoObject

/**
 * All type schemas that are derived from Entity
 */
export type EntityTypes =
  | Entity
  | ArrayValidator
  | Article
  | AudioObject
  | BooleanValidator
  | Brand
  | CitationIntentEnumeration
  | Cite
  | CiteGroup
  | Claim
  | Code
  | CodeBlock
  | CodeChunk
  | CodeError
  | CodeExecutable
  | CodeExpression
  | CodeFragment
  | Collection
  | Comment
  | ConstantValidator
  | ContactPoint
  | CreativeWork
  | Datatable
  | DatatableColumn
  | Date
  | DefinedTerm
  | Delete
  | Emphasis
  | EnumValidator
  | Enumeration
  | Figure
  | Function
  | Grant
  | Heading
  | ImageObject
  | Include
  | IntegerValidator
  | Link
  | List
  | ListItem
  | Mark
  | Math
  | MathBlock
  | MathFragment
  | MediaObject
  | MonetaryGrant
  | NontextualAnnotation
  | Note
  | NumberValidator
  | Organization
  | Paragraph
  | Parameter
  | Periodical
  | Person
  | PostalAddress
  | Product
  | PropertyValue
  | PublicationIssue
  | PublicationVolume
  | Quote
  | QuoteBlock
  | Review
  | SoftwareApplication
  | SoftwareEnvironment
  | SoftwareSession
  | SoftwareSourceCode
  | Strikeout
  | StringValidator
  | Strong
  | Subscript
  | Superscript
  | Table
  | TableCell
  | TableRow
  | ThematicBreak
  | Thing
  | TupleValidator
  | Underline
  | Validator
  | Variable
  | VideoObject
  | VolumeMount

/**
 * All type schemas that are derived from Enumeration
 */
export type EnumerationTypes = Enumeration | CitationIntentEnumeration

/**
 * All type schemas that are derived from Grant
 */
export type GrantTypes = Grant | MonetaryGrant

/**
 * Union type for valid inline content.
 */
export type InlineContent =
  | AudioObject
  | Cite
  | CiteGroup
  | CodeExpression
  | CodeFragment
  | Delete
  | Emphasis
  | ImageObject
  | Link
  | MathFragment
  | NontextualAnnotation
  | Note
  | Parameter
  | Quote
  | Strikeout
  | Strong
  | Subscript
  | Superscript
  | Underline
  | VideoObject
  | null
  | boolean
  | Integer
  | number
  | string

/**
 * All type schemas that are derived from Mark
 */
export type MarkTypes =
  | Mark
  | Delete
  | Emphasis
  | NontextualAnnotation
  | Quote
  | Strikeout
  | Strong
  | Subscript
  | Superscript
  | Underline

/**
 * All type schemas that are derived from Math
 */
export type MathTypes = Math | MathBlock | MathFragment

/**
 * All type schemas that are derived from MediaObject
 */
export type MediaObjectTypes =
  | MediaObject
  | AudioObject
  | ImageObject
  | VideoObject

/**
 * Union type for all types of nodes in this schema, including primitives and entities
 */
export type Node =
  | Entity
  | ArrayValidator
  | Article
  | AudioObject
  | BooleanValidator
  | Brand
  | CitationIntentEnumeration
  | Cite
  | CiteGroup
  | Claim
  | Code
  | CodeBlock
  | CodeChunk
  | CodeError
  | CodeExecutable
  | CodeExpression
  | CodeFragment
  | Collection
  | Comment
  | ConstantValidator
  | ContactPoint
  | CreativeWork
  | Datatable
  | DatatableColumn
  | Date
  | DefinedTerm
  | Delete
  | Emphasis
  | EnumValidator
  | Enumeration
  | Figure
  | Function
  | Grant
  | Heading
  | ImageObject
  | Include
  | IntegerValidator
  | Link
  | List
  | ListItem
  | Mark
  | Math
  | MathBlock
  | MathFragment
  | MediaObject
  | MonetaryGrant
  | NontextualAnnotation
  | Note
  | NumberValidator
  | Organization
  | Paragraph
  | Parameter
  | Periodical
  | Person
  | PostalAddress
  | Product
  | PropertyValue
  | PublicationIssue
  | PublicationVolume
  | Quote
  | QuoteBlock
  | Review
  | SoftwareApplication
  | SoftwareEnvironment
  | SoftwareSession
  | SoftwareSourceCode
  | Strikeout
  | StringValidator
  | Strong
  | Subscript
  | Superscript
  | Table
  | TableCell
  | TableRow
  | ThematicBreak
  | Thing
  | TupleValidator
  | Underline
  | Validator
  | Variable
  | VideoObject
  | VolumeMount
  | null
  | boolean
  | Integer
  | number
  | string
  | { [property: string]: Primitive }
  | Array<Primitive>

/**
 * All type schemas that are derived from NumberValidator
 */
export type NumberValidatorTypes = NumberValidator | IntegerValidator

/**
 * Union type for all primitives values
 */
export type Primitive =
  | null
  | boolean
  | Integer
  | number
  | string
  | { [property: string]: Primitive }
  | Array<Primitive>

/**
 * All type schemas that are derived from Thing
 */
export type ThingTypes =
  | Thing
  | Article
  | AudioObject
  | Brand
  | CitationIntentEnumeration
  | Claim
  | Collection
  | Comment
  | ContactPoint
  | CreativeWork
  | Datatable
  | DatatableColumn
  | DefinedTerm
  | Enumeration
  | Figure
  | Grant
  | ImageObject
  | ListItem
  | MediaObject
  | MonetaryGrant
  | Organization
  | Periodical
  | Person
  | PostalAddress
  | Product
  | PropertyValue
  | PublicationIssue
  | PublicationVolume
  | Review
  | SoftwareApplication
  | SoftwareEnvironment
  | SoftwareSession
  | SoftwareSourceCode
  | Table
  | VideoObject
  | VolumeMount

/**
 * All type schemas that are derived from Validator
 */
export type ValidatorTypes =
  | Validator
  | ArrayValidator
  | BooleanValidator
  | ConstantValidator
  | EnumValidator
  | IntegerValidator
  | NumberValidator
  | StringValidator
  | TupleValidator

/**
 * The type or nature of a citation, both factually and rhetorically.
 */
export enum CitationIntentEnumeration {
  /**
   * The citing entity agrees with statements, ideas or conclusions presented in the cited entity
   */
  AgreesWith = 'AgreesWith',

  /**
   * The citing entity cites the cited entity as one that provides an authoritative description or definition of the subject under discussion
   */
  CitesAsAuthority = 'CitesAsAuthority',

  /**
   * The citing entity cites the cited entity as source of data
   */
  CitesAsDataSource = 'CitesAsDataSource',

  /**
   * The citing entity cites the cited entity as source of factual evidence for statements it contains
   */
  CitesAsEvidence = 'CitesAsEvidence',

  /**
   * The citing entity cites the cited entity as being the container of metadata describing the citing entity
   */
  CitesAsMetadataDocument = 'CitesAsMetadataDocument',

  /**
   * The citing entity cites the cited entity as providing or containing a possible solution to the issues being discussed
   */
  CitesAsPotentialSolution = 'CitesAsPotentialSolution',

  /**
   * The citing entity cites the cited entity as an item of recommended reading
   */
  CitesAsRecommendedReading = 'CitesAsRecommendedReading',

  /**
   * The citing entity cites the cited entity as one that is related
   */
  CitesAsRelated = 'CitesAsRelated',

  /**
   * The citing entity cites the cited entity as being the entity from which the citing entity is derived, or about which the citing entity contains metadata
   */
  CitesAsSourceDocument = 'CitesAsSourceDocument',

  /**
   * The citing entity cites the cited entity as a source of information on the subject under discussion
   */
  CitesForInformation = 'CitesForInformation',

  /**
   * The citing entity is used to create or compile the cited entity
   */
  Compiles = 'Compiles',

  /**
   * The citing entity confirms facts, ideas or statements presented in the cited entity
   */
  Confirms = 'Confirms',

  /**
   * The citing entity contains a statement of fact or a logical assertion (or a collection of such facts and/or assertions) originally present in the cited entity
   */
  ContainsAssertionFrom = 'ContainsAssertionFrom',

  /**
   * The citing entity corrects statements, ideas or conclusions presented in the cited entity
   */
  Corrects = 'Corrects',

  /**
   * The citing entity acknowledges contributions made by the cited entity
   */
  Credits = 'Credits',

  /**
   * The citing entity critiques statements, ideas or conclusions presented in the cited entity
   */
  Critiques = 'Critiques',

  /**
   * The citing entity express derision for the cited entity, or for ideas or conclusions contained within it
   */
  Derides = 'Derides',

  /**
   * The citing entity describes the cited entity
   */
  Describes = 'Describes',

  /**
   * The citing entity disagrees with statements, ideas or conclusions presented in the cited entity
   */
  DisagreesWith = 'DisagreesWith',

  /**
   * The citing entity discusses statements, ideas or conclusions presented in the cited entity
   */
  Discusses = 'Discusses',

  /**
   * The citing entity disputes statements, ideas or conclusions presented in the cited entity
   */
  Disputes = 'Disputes',

  /**
   * The citing entity documents information about the cited entity
   */
  Documents = 'Documents',

  /**
   * The citing entity extends facts, ideas or understandings presented in the cited entity
   */
  Extends = 'Extends',

  /**
   * The cited entity provides background information for the citing entity
   */
  GivesBackgroundTo = 'GivesBackgroundTo',

  /**
   * The cited entity provides intellectual or factual support for the citing entity
   */
  GivesSupportTo = 'GivesSupportTo',

  /**
   * The cited entity evokes a reply from the citing entity
   */
  HasReplyFrom = 'HasReplyFrom',

  /**
   * The citing entity includes one or more excerpts from the cited entity
   */
  IncludesExcerptFrom = 'IncludesExcerptFrom',

  /**
   * The citing entity includes one or more quotations from the cited entity
   */
  IncludesQuotationFrom = 'IncludesQuotationFrom',

  /**
   * The cited entity contains statements, ideas or conclusions with which the citing entity agrees
   */
  IsAgreedWithBy = 'IsAgreedWithBy',

  /**
   * The cited entity is cited as providing an authoritative description or definition of the subject under discussion in the citing entity
   */
  IsCitedAsAuthorityBy = 'IsCitedAsAuthorityBy',

  /**
   * The cited entity is cited as a data source by the citing entity
   */
  IsCitedAsDataSourceBy = 'IsCitedAsDataSourceBy',

  /**
   * The cited entity is cited for providing factual evidence to the citing entity
   */
  IsCitedAsEvidenceBy = 'IsCitedAsEvidenceBy',

  /**
   * The cited entity is cited as being the container of metadata relating to the citing entity
   */
  IsCitedAsMetadataDocumentBy = 'IsCitedAsMetadataDocumentBy',

  /**
   * The cited entity is cited as providing or containing a possible solution to the issues being discussed in the citing entity
   */
  IsCitedAsPontentialSolutionBy = 'IsCitedAsPontentialSolutionBy',

  /**
   * The cited entity is cited by the citing entity as an item of recommended reading
   */
  IsCitedAsRecommendedReadingBy = 'IsCitedAsRecommendedReadingBy',

  /**
   * The cited entity is cited as being related to the citing entity
   */
  IsCitedAsRelatedBy = 'IsCitedAsRelatedBy',

  /**
   * The cited entity is cited as being the entity from which the citing entity is derived, or about which the citing entity contains metadata
   */
  IsCitedAsSourceDocumentBy = 'IsCitedAsSourceDocumentBy',

  /**
   * The cited entity (the subject of the RDF triple) is cited by the citing entity (the object of the triple)
   */
  IsCitedBy = 'IsCitedBy',

  /**
   * The cited entity is cited as a source of information on the subject under discussion in the citing entity
   */
  IsCitedForInformationBy = 'IsCitedForInformationBy',

  /**
   * The cited entity is the result of a compile or creation event using the citing entity
   */
  IsCompiledBy = 'IsCompiledBy',

  /**
   * The cited entity presents facts, ideas or statements that are confirmed by the citing entity
   */
  IsConfirmedBy = 'IsConfirmedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are corrected by the citing entity
   */
  IsCorrectedBy = 'IsCorrectedBy',

  /**
   * The cited entity makes contributions that are acknowledged by the citing entity
   */
  IsCreditedBy = 'IsCreditedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are critiqued by the citing entity
   */
  IsCritiquedBy = 'IsCritiquedBy',

  /**
   * The cited entity contains ideas or conclusions for which the citing entity express derision
   */
  IsDeridedBy = 'IsDeridedBy',

  /**
   * The cited entity is described by the citing entity
   */
  IsDescribedBy = 'IsDescribedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are disagreed with by the citing entity
   */
  IsDisagreedWithBy = 'IsDisagreedWithBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are discussed by the citing entity
   */
  IsDiscussedBy = 'IsDiscussedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are disputed by the citing entity
   */
  IsDisputedBy = 'IsDisputedBy',

  /**
   * Information about the cited entity is documented by the citing entity
   */
  IsDocumentedBy = 'IsDocumentedBy',

  /**
   * The cited entity presents facts, ideas or understandings that are extended by the citing entity
   */
  IsExtendedBy = 'IsExtendedBy',

  /**
   * The cited entity is the target for an HTTP Uniform Resource Locator (URL) link within the citing entity
   */
  IsLinkedToBy = 'IsLinkedToBy',

  /**
   * The characteristic style or content of the cited entity is imitated by the citing entity for comic effect, usually without explicit citation
   */
  IsParodiedBy = 'IsParodiedBy',

  /**
   * The cited entity is plagiarized by the author of the citing entity, who includes within the citing entity textual or other elements from the cited entity without formal acknowledgement of their source
   */
  IsPlagiarizedBy = 'IsPlagiarizedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are qualified or have conditions placed upon them by the citing entity
   */
  IsQualifiedBy = 'IsQualifiedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are refuted by the citing entity
   */
  IsRefutedBy = 'IsRefutedBy',

  /**
   * The cited entity is formally retracted by the citing entity
   */
  IsRetractedBy = 'IsRetractedBy',

  /**
   * The cited entity presents statements, ideas or conclusions that are reviewed by the citing entity
   */
  IsReviewedBy = 'IsReviewedBy',

  /**
   * The cited entity or aspects of its contents are ridiculed by the citing entity
   */
  IsRidiculedBy = 'IsRidiculedBy',

  /**
   * The cited entity is cited because the citing article contains speculations on its content or ideas
   */
  IsSpeculatedOnBy = 'IsSpeculatedOnBy',

  /**
   * The cited entity receives intellectual or factual support from the citing entity
   */
  IsSupportedBy = 'IsSupportedBy',

  /**
   * The cited entity presents statements, ideas, hypotheses or understanding that are updated by the cited entity
   */
  IsUpdatedBy = 'IsUpdatedBy',

  /**
   * A property that permits you to express appreciation of or interest in something that is the object of the RDF triple, or to express that it is worth thinking about even if you do not agree with its content, enabling social media 'likes' statements to be encoded in RDF
   */
  Likes = 'Likes',

  /**
   * The citing entity provides a link, in the form of an HTTP Uniform Resource Locator (URL), to the cited entity
   */
  LinksTo = 'LinksTo',

  /**
   * The citing entity obtains background information from the cited entity
   */
  ObtainsBackgroundFrom = 'ObtainsBackgroundFrom',

  /**
   * The citing entity obtains intellectual or factual support from the cited entity
   */
  ObtainsSupportFrom = 'ObtainsSupportFrom',

  /**
   * The citing entity imitates the characteristic style or content of the cited entity for comic effect, usually without explicit citation
   */
  Parodies = 'Parodies',

  /**
   * A property indicating that the author of the citing entity plagiarizes the cited entity, by including textual or other elements from the cited entity without formal acknowledgement of their source
   */
  Plagiarizes = 'Plagiarizes',

  /**
   * The cited entity contains and is the original source of a statement of fact or a logical assertion (or a collection of such facts and/or assertions) that is to be found in the citing entity
   */
  ProvidesAssertionFor = 'ProvidesAssertionFor',

  /**
   * The cited entity presents conclusions that are used in work described in the citing entity
   */
  ProvidesConclusionsFor = 'ProvidesConclusionsFor',

  /**
   * The cited entity presents data that are used in work described in the citing entity
   */
  ProvidesDataFor = 'ProvidesDataFor',

  /**
   * The cited entity contains information, usually of a textual nature, that is excerpted by (used as an excerpt within) the citing entity
   */
  ProvidesExcerptFor = 'ProvidesExcerptFor',

  /**
   * The cited entity details a method that is used in work described by the citing entity
   */
  ProvidesMethodFor = 'ProvidesMethodFor',

  /**
   * The cited entity contains information, usually of a textual nature, that is quoted by (used as a quotation within) the citing entity
   */
  ProvidesQuotationFor = 'ProvidesQuotationFor',

  /**
   * The citing entity qualifies or places conditions or restrictions upon statements, ideas or conclusions presented in the cited entity
   */
  Qualifies = 'Qualifies',

  /**
   * The citing entity refutes statements, ideas or conclusions presented in the cited entity
   */
  Refutes = 'Refutes',

  /**
   * The citing entity replies to statements, ideas or criticisms presented in the cited entity
   */
  RepliesTo = 'RepliesTo',

  /**
   * The citing entity constitutes a formal retraction of the cited entity
   */
  Retracts = 'Retracts',

  /**
   * The citing entity reviews statements, ideas or conclusions presented in the cited entity
   */
  Reviews = 'Reviews',

  /**
   * The citing entity ridicules the cited entity or aspects of its contents
   */
  Ridicules = 'Ridicules',

  /**
   * Each entity has at least one author that shares a common institutional affiliation with an author of the other entity
   */
  SharesAuthorInstitutionWith = 'SharesAuthorInstitutionWith',

  /**
   * Each entity has at least one author in common with the other entity
   */
  SharesAuthorWith = 'SharesAuthorWith',

  /**
   * The two entities result from activities that have been funded by the same funding agency
   */
  SharesFundingAgencyWith = 'SharesFundingAgencyWith',

  /**
   * The citing and cited bibliographic resources are published in the same journal
   */
  SharesJournalWith = 'SharesJournalWith',

  /**
   * The citing and cited bibliographic resources are published in same publication venue
   */
  SharesPublicationVenueWith = 'SharesPublicationVenueWith',

  /**
   * The citing entity speculates on something within or related to the cited entity, without firm evidence
   */
  SpeculatesOn = 'SpeculatesOn',

  /**
   * The citing entity provides intellectual or factual support for statements, ideas or conclusions presented in the cited entity
   */
  Supports = 'Supports',

  /**
   * The citing entity updates statements, ideas, hypotheses or understanding presented in the cited entity
   */
  Updates = 'Updates',

  /**
   * The citing entity describes work that uses conclusions presented in the cited entity
   */
  UsesConclusionsFrom = 'UsesConclusionsFrom',

  /**
   * The citing entity describes work that uses data presented in the cited entity
   */
  UsesDataFrom = 'UsesDataFrom',

  /**
   * The citing entity describes work that uses a method detailed in the cited entity
   */
  UsesMethodIn = 'UsesMethodIn',
}

export type TypeMap<T extends Entity = Entity> = { [key in T['type']]: key }

export const codeExecutableTypes: TypeMap<
  Exclude<CodeExecutableTypes, Primitive>
> = {
  CodeExecutable: 'CodeExecutable',
  CodeChunk: 'CodeChunk',
  CodeExpression: 'CodeExpression',
}
export const codeTypes: TypeMap<Exclude<CodeTypes, Primitive>> = {
  Code: 'Code',
  CodeBlock: 'CodeBlock',
  CodeChunk: 'CodeChunk',
  CodeExecutable: 'CodeExecutable',
  CodeExpression: 'CodeExpression',
  CodeFragment: 'CodeFragment',
}
export const contactPointTypes: TypeMap<Exclude<ContactPointTypes, Primitive>> =
  {
    ContactPoint: 'ContactPoint',
    PostalAddress: 'PostalAddress',
  }
export const creativeWorkTypes: TypeMap<Exclude<CreativeWorkTypes, Primitive>> =
  {
    CreativeWork: 'CreativeWork',
    Article: 'Article',
    AudioObject: 'AudioObject',
    Claim: 'Claim',
    Collection: 'Collection',
    Comment: 'Comment',
    Datatable: 'Datatable',
    Figure: 'Figure',
    ImageObject: 'ImageObject',
    MediaObject: 'MediaObject',
    Periodical: 'Periodical',
    PublicationIssue: 'PublicationIssue',
    PublicationVolume: 'PublicationVolume',
    Review: 'Review',
    SoftwareApplication: 'SoftwareApplication',
    SoftwareSourceCode: 'SoftwareSourceCode',
    Table: 'Table',
    VideoObject: 'VideoObject',
  }
export const entityTypes: TypeMap<Exclude<EntityTypes, Primitive>> = {
  Entity: 'Entity',
  ArrayValidator: 'ArrayValidator',
  Article: 'Article',
  AudioObject: 'AudioObject',
  BooleanValidator: 'BooleanValidator',
  Brand: 'Brand',
  CitationIntentEnumeration: 'CitationIntentEnumeration',
  Cite: 'Cite',
  CiteGroup: 'CiteGroup',
  Claim: 'Claim',
  Code: 'Code',
  CodeBlock: 'CodeBlock',
  CodeChunk: 'CodeChunk',
  CodeError: 'CodeError',
  CodeExecutable: 'CodeExecutable',
  CodeExpression: 'CodeExpression',
  CodeFragment: 'CodeFragment',
  Collection: 'Collection',
  Comment: 'Comment',
  ConstantValidator: 'ConstantValidator',
  ContactPoint: 'ContactPoint',
  CreativeWork: 'CreativeWork',
  Datatable: 'Datatable',
  DatatableColumn: 'DatatableColumn',
  Date: 'Date',
  DefinedTerm: 'DefinedTerm',
  Delete: 'Delete',
  Emphasis: 'Emphasis',
  EnumValidator: 'EnumValidator',
  Enumeration: 'Enumeration',
  Figure: 'Figure',
  Function: 'Function',
  Grant: 'Grant',
  Heading: 'Heading',
  ImageObject: 'ImageObject',
  Include: 'Include',
  IntegerValidator: 'IntegerValidator',
  Link: 'Link',
  List: 'List',
  ListItem: 'ListItem',
  Mark: 'Mark',
  Math: 'Math',
  MathBlock: 'MathBlock',
  MathFragment: 'MathFragment',
  MediaObject: 'MediaObject',
  MonetaryGrant: 'MonetaryGrant',
  NontextualAnnotation: 'NontextualAnnotation',
  Note: 'Note',
  NumberValidator: 'NumberValidator',
  Organization: 'Organization',
  Paragraph: 'Paragraph',
  Parameter: 'Parameter',
  Periodical: 'Periodical',
  Person: 'Person',
  PostalAddress: 'PostalAddress',
  Product: 'Product',
  PropertyValue: 'PropertyValue',
  PublicationIssue: 'PublicationIssue',
  PublicationVolume: 'PublicationVolume',
  Quote: 'Quote',
  QuoteBlock: 'QuoteBlock',
  Review: 'Review',
  SoftwareApplication: 'SoftwareApplication',
  SoftwareEnvironment: 'SoftwareEnvironment',
  SoftwareSession: 'SoftwareSession',
  SoftwareSourceCode: 'SoftwareSourceCode',
  Strikeout: 'Strikeout',
  StringValidator: 'StringValidator',
  Strong: 'Strong',
  Subscript: 'Subscript',
  Superscript: 'Superscript',
  Table: 'Table',
  TableCell: 'TableCell',
  TableRow: 'TableRow',
  ThematicBreak: 'ThematicBreak',
  Thing: 'Thing',
  TupleValidator: 'TupleValidator',
  Underline: 'Underline',
  Validator: 'Validator',
  Variable: 'Variable',
  VideoObject: 'VideoObject',
  VolumeMount: 'VolumeMount',
}
export const enumerationTypes: TypeMap<Exclude<EnumerationTypes, Primitive>> = {
  Enumeration: 'Enumeration',
  CitationIntentEnumeration: 'CitationIntentEnumeration',
}
export const grantTypes: TypeMap<Exclude<GrantTypes, Primitive>> = {
  Grant: 'Grant',
  MonetaryGrant: 'MonetaryGrant',
}
export const markTypes: TypeMap<Exclude<MarkTypes, Primitive>> = {
  Mark: 'Mark',
  Delete: 'Delete',
  Emphasis: 'Emphasis',
  NontextualAnnotation: 'NontextualAnnotation',
  Quote: 'Quote',
  Strikeout: 'Strikeout',
  Strong: 'Strong',
  Subscript: 'Subscript',
  Superscript: 'Superscript',
  Underline: 'Underline',
}
export const mathTypes: TypeMap<Exclude<MathTypes, Primitive>> = {
  Math: 'Math',
  MathBlock: 'MathBlock',
  MathFragment: 'MathFragment',
}
export const mediaObjectTypes: TypeMap<Exclude<MediaObjectTypes, Primitive>> = {
  MediaObject: 'MediaObject',
  AudioObject: 'AudioObject',
  ImageObject: 'ImageObject',
  VideoObject: 'VideoObject',
}
export const numberValidatorTypes: TypeMap<
  Exclude<NumberValidatorTypes, Primitive>
> = {
  NumberValidator: 'NumberValidator',
  IntegerValidator: 'IntegerValidator',
}
export const thingTypes: TypeMap<Exclude<ThingTypes, Primitive>> = {
  Thing: 'Thing',
  Article: 'Article',
  AudioObject: 'AudioObject',
  Brand: 'Brand',
  CitationIntentEnumeration: 'CitationIntentEnumeration',
  Claim: 'Claim',
  Collection: 'Collection',
  Comment: 'Comment',
  ContactPoint: 'ContactPoint',
  CreativeWork: 'CreativeWork',
  Datatable: 'Datatable',
  DatatableColumn: 'DatatableColumn',
  DefinedTerm: 'DefinedTerm',
  Enumeration: 'Enumeration',
  Figure: 'Figure',
  Grant: 'Grant',
  ImageObject: 'ImageObject',
  ListItem: 'ListItem',
  MediaObject: 'MediaObject',
  MonetaryGrant: 'MonetaryGrant',
  Organization: 'Organization',
  Periodical: 'Periodical',
  Person: 'Person',
  PostalAddress: 'PostalAddress',
  Product: 'Product',
  PropertyValue: 'PropertyValue',
  PublicationIssue: 'PublicationIssue',
  PublicationVolume: 'PublicationVolume',
  Review: 'Review',
  SoftwareApplication: 'SoftwareApplication',
  SoftwareEnvironment: 'SoftwareEnvironment',
  SoftwareSession: 'SoftwareSession',
  SoftwareSourceCode: 'SoftwareSourceCode',
  Table: 'Table',
  VideoObject: 'VideoObject',
  VolumeMount: 'VolumeMount',
}
export const validatorTypes: TypeMap<Exclude<ValidatorTypes, Primitive>> = {
  Validator: 'Validator',
  ArrayValidator: 'ArrayValidator',
  BooleanValidator: 'BooleanValidator',
  ConstantValidator: 'ConstantValidator',
  EnumValidator: 'EnumValidator',
  IntegerValidator: 'IntegerValidator',
  NumberValidator: 'NumberValidator',
  StringValidator: 'StringValidator',
  TupleValidator: 'TupleValidator',
}
export const blockContentTypes: TypeMap<Exclude<BlockContent, Primitive>> = {
  Claim: 'Claim',
  CodeBlock: 'CodeBlock',
  CodeChunk: 'CodeChunk',
  Collection: 'Collection',
  Figure: 'Figure',
  Heading: 'Heading',
  Include: 'Include',
  List: 'List',
  MathBlock: 'MathBlock',
  Paragraph: 'Paragraph',
  QuoteBlock: 'QuoteBlock',
  Table: 'Table',
  ThematicBreak: 'ThematicBreak',
}
export const inlineContentTypes: TypeMap<Exclude<InlineContent, Primitive>> = {
  AudioObject: 'AudioObject',
  Cite: 'Cite',
  CiteGroup: 'CiteGroup',
  CodeExpression: 'CodeExpression',
  CodeFragment: 'CodeFragment',
  Delete: 'Delete',
  Emphasis: 'Emphasis',
  ImageObject: 'ImageObject',
  Link: 'Link',
  MathFragment: 'MathFragment',
  NontextualAnnotation: 'NontextualAnnotation',
  Note: 'Note',
  Parameter: 'Parameter',
  Quote: 'Quote',
  Strikeout: 'Strikeout',
  Strong: 'Strong',
  Subscript: 'Subscript',
  Superscript: 'Superscript',
  Underline: 'Underline',
  VideoObject: 'VideoObject',
}

export interface Unions {
  CodeExecutableTypes: CodeExecutableTypes
  CodeTypes: CodeTypes
  ContactPointTypes: ContactPointTypes
  CreativeWorkTypes: CreativeWorkTypes
  EntityTypes: EntityTypes
  EnumerationTypes: EnumerationTypes
  GrantTypes: GrantTypes
  MarkTypes: MarkTypes
  MathTypes: MathTypes
  MediaObjectTypes: MediaObjectTypes
  NumberValidatorTypes: NumberValidatorTypes
  ThingTypes: ThingTypes
  ValidatorTypes: ValidatorTypes
  BlockContent: BlockContent
  InlineContent: InlineContent
}

export const unions = {
  CodeExecutableTypes: codeExecutableTypes,
  CodeTypes: codeTypes,
  ContactPointTypes: contactPointTypes,
  CreativeWorkTypes: creativeWorkTypes,
  EntityTypes: entityTypes,
  EnumerationTypes: enumerationTypes,
  GrantTypes: grantTypes,
  MarkTypes: markTypes,
  MathTypes: mathTypes,
  MediaObjectTypes: mediaObjectTypes,
  NumberValidatorTypes: numberValidatorTypes,
  ThingTypes: thingTypes,
  ValidatorTypes: validatorTypes,
  BlockContent: blockContentTypes,
  InlineContent: inlineContentTypes,
}
