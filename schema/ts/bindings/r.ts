/** `
 * Module for generating R language bindings.
 */

import fs from 'fs-extra'
import { JSONSchema7TypeName } from 'json-schema'
import path from 'path'
import { JsonSchema } from '../JsonSchema'
import {
  autogeneratedHeader,
  filterEnumSchemas,
  filterInterfaceSchemas,
  filterUnionSchemas,
  getSchemaProperties,
  readSchemas,
} from '../util/helpers'

const DEST_FOLDER = path.join(__dirname, '..', '..', '..', 'r', 'R')

/**
 * Run `build()` when this file is run as a Node script
 */
// eslint-disable-next-line @typescript-eslint/no-floating-promises
if (module.parent === null) build()

/**
 * Generate `../../r/R/types.R` from schemas.
 */
async function build(): Promise<void> {
  const schemas = await readSchemas()

  const code = `${autogeneratedHeader(
    'build:r',
    path.basename(__filename),
    '#'
  )}

#' @include typing.R
NULL

${filterInterfaceSchemas(schemas).map(classGenerator).join('\n')}

${filterEnumSchemas(schemas).map(enumGenerator).join('\n')}

${filterUnionSchemas(schemas).map(unionGenerator).join('\n')}
`

  await fs.writeFile(path.join(DEST_FOLDER, 'types.R'), code)
}

/**
 * Generate a constructor function for a normal type.
 */
export function classGenerator(schema: JsonSchema): string {
  const { title = 'Untitled', extends: parent, description = title } = schema
  const { all, inherited, own } = getSchemaProperties(schema)

  let code = docComment(description, [
    `@name ${title}`,
    ...all.map(
      ({ name, schema, optional }) =>
        `@param ${name} ${schema.description ?? ''} ${
          !optional ? `\\bold{Required}.` : ''
        }`
    ),
    `@return A \`list\` of class \`${title}\``,
    ...(parent !== undefined ? [`@seealso \\code{\\link{${parent}}}`] : []),
    '@export',
  ])

  if (examples[title] !== undefined) {
    code +=
      "#' @examples\n" +
      examples[title]
        .trim()
        .split(/\n\r?/)
        .map((line) => `#' ${line}`)
        .join('\n') +
      '\n'
  }

  code += `${title} <- function(\n`
  code += all.map(({ name }) => `  ${name}`).join(',\n')
  code += `\n){\n`

  if (parent === undefined) {
    code += `  self <- list()\n`
  } else {
    code += `  self <- ${parent}(\n`
    code += inherited.map(({ name }) => `    ${name} = ${name}`).join(',\n')
    code += '\n  )\n'
  }

  code += `  self$type <- as_scalar("${title}")\n`

  code += own
    .map(({ name, optional, schema }) => {
      const type = schemaToType(schema)
      return `  self[["${name}"]] <- check_property("${title}", "${name}", ${
        optional ? 'FALSE' : 'TRUE'
      }, missing(${name}), ${type}, ${name})`
    })
    .join('\n')

  code += `\n  class(self) <- c(class(self), "${title}")`

  code += `\n  self`
  code += `\n}\n\n`

  return code
}

/**
 * Generate a R `Enum` class.
 */
export function enumGenerator(schema: JsonSchema): string {
  const { title = '', description = title, anyOf = [] } = schema
  return (
    docComment(description, [
      `@return A \`list\` of class \`Enum\` describing valid members of this enumeration`,
      '@export',
    ]) +
    `${title} <- Enum(${anyOf
      .map(({ const: const_ = '' }) => `"${const_ as string}"`)
      .join(', ')})
`
  )
}

/**
 * Generate a R `Union` class.
 */
export function unionGenerator(schema: JsonSchema): string {
  const { title = '', description = title } = schema
  let code = docComment(description, [
    `@return A \`list\` of class \`Union\` describing valid subtypes of this type`,
    '@export',
  ])
  code += `${title} <- ${schemaToType(schema)}\n\n`
  return code
}

/**
 * Generate a [roxygen](https://github.com/klutometis/roxygen) style
 * doc comments
 */
function docComment(description: string, tags: string[] = []): string {
  return (
    "#' " +
    description.trim().replace(/[\n\r]+/g, ' ') +
    '\n' +
    "#'\n" +
    tags.map((tag) => "#' " + tag.trim().replace(/[\n\r]+/g, ' ')).join('\n') +
    '\n'
  )
}

/**
 * Convert a schema definition to a R class
 */
function schemaToType(schema: JsonSchema): string {
  let { type, anyOf, allOf, $ref } = schema

  if ($ref !== undefined) {
    const name = $ref.replace('.schema.json', '')
    if (
      [
        'Null',
        'Boolean',
        'Integer',
        'Number',
        'String',
        'Array',
        'Object',
      ].includes(name)
    ) {
      type = name.toLowerCase() as JSONSchema7TypeName
    } else {
      return `${name}`
    }
  }
  if (anyOf !== undefined) return anyOfToType(anyOf)
  if (allOf !== undefined) return allOfToType(allOf)
  if (schema.enum !== undefined) return enumToType(schema.enum)

  if (type === 'null') return '"NULL"'
  if (type === 'boolean') return '"logical"'
  if (type === 'number') return '"numeric"'
  if (type === 'integer') return '"numeric"'
  if (type === 'string') return '"character"'
  if (type === 'array') return arrayToType(schema)
  if (type === 'object') return '"list"'

  throw new Error(`Unhandled schema: ${JSON.stringify(schema)}`)
}

/**
 * Convert a schema with the `anyOf` property to a `Union` type checker.
 */
function anyOfToType(anyOf: JsonSchema[]): string {
  const types = anyOf
    .map((schema) => schemaToType(schema))
    .reduce(
      (prev: string[], curr) => (prev.includes(curr) ? prev : [...prev, curr]),
      []
    )
  if (types.length === 0) return ''
  if (types.length === 1) return types[0]
  return `Union(${types
    // This mapping avoids the recursive union type definition that will
    // arise otherwise for the `Node` union type.
    .map((type) => (type === 'Array(Node)' ? 'Array("Node")' : type))
    .join(', ')})`
}

/**
 * Convert a schema with the `allOf` property to a type.
 */
function allOfToType(allOf: JsonSchema[]): string {
  if (allOf.length === 1) return schemaToType(allOf[0])
  else return schemaToType(allOf[allOf.length - 1])
}

/**
 * Convert a schema with the `array` property to an `Array` type checker.
 */
function arrayToType(schema: JsonSchema): string {
  const items = Array.isArray(schema.items)
    ? anyOfToType(schema.items)
    : schema.items !== undefined
    ? schemaToType(schema.items)
    : 'Any()'
  return `Array(${items})`
}

/**
 * Convert a schema with the `enum` property to an `Enum` type checker.
 */
export function enumToType(enu: (string | number)[]): string {
  const values = enu
    .map((schema) => {
      return JSON.stringify(schema)
    })
    .join(', ')
  return `Enum(${values})`
}

/**
 * Examples of usage for various function to be inserted into docstrings
 */
const examples: Record<string, string> = {
  Person: `
Person(
  honorificPrefix = "Dr",
  givenNames = list("Jane", "J"),
  familyNames = list("Jamieson")
)`,
  CodeChunk: `
CodeChunk(
  programmingLanguage = "r",
  text = "plot(1)",
  label = "Figure 1",
  id = "fig1",
  caption = list(
    Heading(
      content = list("Figure title"),
      depth = 2
    ),
    Paragraph(
      content = list(
        "A paragraph with some",
        Strong(content = list("strong emphasis")),
        "in it."
      )
    )
  )
)`,
}
